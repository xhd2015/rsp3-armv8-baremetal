//=====Automatically generated by python 3.6.4
//== working directory: /cygdrive/d/Pool/eclipse-workspace_aarch64/newspace/raspiOS/subprojects/python3_gen_engine/src
//== ../../../subprojects/python3_gen_engine/src/GenEngine.py  ../../../subprojects/python3_gen_engine/src/reg_defs/system_common_registers.py  ../../../include/arch/common_aarch64/registers/system_common_registers.h
#ifndef __INCLUDE_ARCH_COMMON_AARCH64_REGISTERS_SYSTEM_COMMON_REGISTERS_H__
#define __INCLUDE_ARCH_COMMON_AARCH64_REGISTERS_SYSTEM_COMMON_REGISTERS_H__
#include <def.h>
#include <io/Output.h>
#include <io/IntegerFormatter.h>

class RegCurrentEL 
{
public:
    using ScaleType=uint32_t;
            uint32_t  RES0_0:2;
            uint32_t  EL:2;
            uint32_t  RES0_1:28;
    AS_MACRO uint32_t  get()const 
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    AS_MACRO uint32_t  get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }
    
    AS_MACRO RegCurrentEL& set(uint32_t v)
    { 
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    AS_MACRO volatile RegCurrentEL & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    AS_MACRO RegCurrentEL & setMandatoryFields()
    {
        RES0_0 = 0;
        EL = 0;
        RES0_1 = 0;
        return *this;
        }
    AS_MACRO RegCurrentEL copy()const volatile
    {
    	RegCurrentEL res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO RegCurrentEL copy()const
    {
    	RegCurrentEL res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO void dump()const volatile
    {
        kout << "RegCurrentEL: ";
            kout
                << "RES0_0 = " << RES0_0 << ", "
                << "EL = " << EL << ", "
                << "RES0_1 = " << RES0_1 << ", "
                << "\n";
    }
    AS_MACRO void dump()const
    {
    	reinterpret_cast<volatile const RegCurrentEL*>(this)->dump();
    }
    AS_MACRO uint32_t & asuint32_t()
    {
    	return *reinterpret_cast<uint32_t*>(this);
    }
    AS_MACRO const uint32_t & asuint32_t()const
    {
    	return *reinterpret_cast<const uint32_t*>(this);
    }
    AS_MACRO static RegCurrentEL make(uint32_t val)
    {
        RegCurrentEL res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    AS_MACRO static RegCurrentEL read()
    { 
        RegCurrentEL res;
        __asm__ __volatile__("mrs %0,CurrentEL\n\t":"=r"(res));
        return res;
    }
    AS_MACRO RegCurrentEL & update()
    {
        __asm__ __volatile__("mrs %0,CurrentEL\n\t":"=r"(*this));
        return *this;
    }
    AS_MACRO void write()const
    {
        __asm__ __volatile__("msr CurrentEL,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegDAIF 
{
public:
    using ScaleType=uint32_t;
            uint32_t  RES0_0:6;
            uint32_t  F:1;
            uint32_t  I:1;
            uint32_t  A:1;
            uint32_t  D:1;
            uint32_t  RES0_1:22;
    AS_MACRO uint32_t  get()const 
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    AS_MACRO uint32_t  get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }
    
    AS_MACRO RegDAIF& set(uint32_t v)
    { 
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    AS_MACRO volatile RegDAIF & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    AS_MACRO RegDAIF & setMandatoryFields()
    {
        RES0_0 = 0;
        F = 0;
        I = 0;
        A = 0;
        D = 0;
        RES0_1 = 0;
        return *this;
        }
    AS_MACRO RegDAIF copy()const volatile
    {
    	RegDAIF res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO RegDAIF copy()const
    {
    	RegDAIF res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO void dump()const volatile
    {
        kout << "RegDAIF: ";
            kout
                << "RES0_0 = " << RES0_0 << ", "
                << "F = " << F << ", "
                << "I = " << I << ", "
                << "A = " << A << ", "
                << "D = " << D << ", "
                << "RES0_1 = " << RES0_1 << ", "
                << "\n";
    }
    AS_MACRO void dump()const
    {
    	reinterpret_cast<volatile const RegDAIF*>(this)->dump();
    }
    AS_MACRO uint32_t & asuint32_t()
    {
    	return *reinterpret_cast<uint32_t*>(this);
    }
    AS_MACRO const uint32_t & asuint32_t()const
    {
    	return *reinterpret_cast<const uint32_t*>(this);
    }
    AS_MACRO static RegDAIF make(uint32_t val)
    {
        RegDAIF res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    AS_MACRO static RegDAIF read()
    { 
        RegDAIF res;
        __asm__ __volatile__("mrs %0,DAIF\n\t":"=r"(res));
        return res;
    }
    AS_MACRO RegDAIF & update()
    {
        __asm__ __volatile__("mrs %0,DAIF\n\t":"=r"(*this));
        return *this;
    }
    AS_MACRO void write()const
    {
        __asm__ __volatile__("msr DAIF,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegVBAR_EL1 
{
public:
    using ScaleType=uint64_t;
            uint64_t  Addr:64;
    AS_MACRO uint64_t  get()const 
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    AS_MACRO uint64_t  get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }
    
    AS_MACRO RegVBAR_EL1& set(uint64_t v)
    { 
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    AS_MACRO volatile RegVBAR_EL1 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    AS_MACRO RegVBAR_EL1 & setMandatoryFields()
    {
        Addr = 0;
        return *this;
        }
    AS_MACRO RegVBAR_EL1 copy()const volatile
    {
    	RegVBAR_EL1 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO RegVBAR_EL1 copy()const
    {
    	RegVBAR_EL1 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO void dump()const volatile
    {
        kout << "RegVBAR_EL1: ";
            kout
                << "Addr = " << Hex(Addr) << ", "
                << "\n";
    }
    AS_MACRO void dump()const
    {
    	reinterpret_cast<volatile const RegVBAR_EL1*>(this)->dump();
    }
    AS_MACRO uint64_t & asuint64_t()
    {
    	return *reinterpret_cast<uint64_t*>(this);
    }
    AS_MACRO const uint64_t & asuint64_t()const
    {
    	return *reinterpret_cast<const uint64_t*>(this);
    }
    AS_MACRO static RegVBAR_EL1 make(uint64_t val)
    {
        RegVBAR_EL1 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    AS_MACRO static RegVBAR_EL1 read()
    { 
        RegVBAR_EL1 res;
        __asm__ __volatile__("mrs %0,VBAR_EL1\n\t":"=r"(res));
        return res;
    }
    AS_MACRO RegVBAR_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,VBAR_EL1\n\t":"=r"(*this));
        return *this;
    }
    AS_MACRO void write()const
    {
        __asm__ __volatile__("msr VBAR_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegVBAR_EL2 
{
public:
    using ScaleType=uint64_t;
            uint64_t  Addr:64;
    AS_MACRO uint64_t  get()const 
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    AS_MACRO uint64_t  get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }
    
    AS_MACRO RegVBAR_EL2& set(uint64_t v)
    { 
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    AS_MACRO volatile RegVBAR_EL2 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    AS_MACRO RegVBAR_EL2 & setMandatoryFields()
    {
        Addr = 0;
        return *this;
        }
    AS_MACRO RegVBAR_EL2 copy()const volatile
    {
    	RegVBAR_EL2 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO RegVBAR_EL2 copy()const
    {
    	RegVBAR_EL2 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO void dump()const volatile
    {
        kout << "RegVBAR_EL2: ";
            kout
                << "Addr = " << Hex(Addr) << ", "
                << "\n";
    }
    AS_MACRO void dump()const
    {
    	reinterpret_cast<volatile const RegVBAR_EL2*>(this)->dump();
    }
    AS_MACRO uint64_t & asuint64_t()
    {
    	return *reinterpret_cast<uint64_t*>(this);
    }
    AS_MACRO const uint64_t & asuint64_t()const
    {
    	return *reinterpret_cast<const uint64_t*>(this);
    }
    AS_MACRO static RegVBAR_EL2 make(uint64_t val)
    {
        RegVBAR_EL2 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    AS_MACRO static RegVBAR_EL2 read()
    { 
        RegVBAR_EL2 res;
        __asm__ __volatile__("mrs %0,VBAR_EL2\n\t":"=r"(res));
        return res;
    }
    AS_MACRO RegVBAR_EL2 & update()
    {
        __asm__ __volatile__("mrs %0,VBAR_EL2\n\t":"=r"(*this));
        return *this;
    }
    AS_MACRO void write()const
    {
        __asm__ __volatile__("msr VBAR_EL2,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegVBAR_EL3 
{
public:
    using ScaleType=uint64_t;
            uint64_t  Addr:64;
    AS_MACRO uint64_t  get()const 
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    AS_MACRO uint64_t  get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }
    
    AS_MACRO RegVBAR_EL3& set(uint64_t v)
    { 
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    AS_MACRO volatile RegVBAR_EL3 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    AS_MACRO RegVBAR_EL3 & setMandatoryFields()
    {
        Addr = 0;
        return *this;
        }
    AS_MACRO RegVBAR_EL3 copy()const volatile
    {
    	RegVBAR_EL3 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO RegVBAR_EL3 copy()const
    {
    	RegVBAR_EL3 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO void dump()const volatile
    {
        kout << "RegVBAR_EL3: ";
            kout
                << "Addr = " << Hex(Addr) << ", "
                << "\n";
    }
    AS_MACRO void dump()const
    {
    	reinterpret_cast<volatile const RegVBAR_EL3*>(this)->dump();
    }
    AS_MACRO uint64_t & asuint64_t()
    {
    	return *reinterpret_cast<uint64_t*>(this);
    }
    AS_MACRO const uint64_t & asuint64_t()const
    {
    	return *reinterpret_cast<const uint64_t*>(this);
    }
    AS_MACRO static RegVBAR_EL3 make(uint64_t val)
    {
        RegVBAR_EL3 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    AS_MACRO static RegVBAR_EL3 read()
    { 
        RegVBAR_EL3 res;
        __asm__ __volatile__("mrs %0,VBAR_EL3\n\t":"=r"(res));
        return res;
    }
    AS_MACRO RegVBAR_EL3 & update()
    {
        __asm__ __volatile__("mrs %0,VBAR_EL3\n\t":"=r"(*this));
        return *this;
    }
    AS_MACRO void write()const
    {
        __asm__ __volatile__("msr VBAR_EL3,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegELR_EL1 
{
public:
    using ScaleType=uint64_t;
            uint64_t  returnAddr:64;
    AS_MACRO uint64_t  get()const 
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    AS_MACRO uint64_t  get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }
    
    AS_MACRO RegELR_EL1& set(uint64_t v)
    { 
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    AS_MACRO volatile RegELR_EL1 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    AS_MACRO RegELR_EL1 & setMandatoryFields()
    {
        returnAddr = 0;
        return *this;
        }
    AS_MACRO RegELR_EL1 copy()const volatile
    {
    	RegELR_EL1 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO RegELR_EL1 copy()const
    {
    	RegELR_EL1 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO void dump()const volatile
    {
        kout << "RegELR_EL1: ";
            kout
                << "returnAddr = " << Hex(returnAddr) << ", "
                << "\n";
    }
    AS_MACRO void dump()const
    {
    	reinterpret_cast<volatile const RegELR_EL1*>(this)->dump();
    }
    AS_MACRO uint64_t & asuint64_t()
    {
    	return *reinterpret_cast<uint64_t*>(this);
    }
    AS_MACRO const uint64_t & asuint64_t()const
    {
    	return *reinterpret_cast<const uint64_t*>(this);
    }
    AS_MACRO static RegELR_EL1 make(uint64_t val)
    {
        RegELR_EL1 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    AS_MACRO static RegELR_EL1 read()
    { 
        RegELR_EL1 res;
        __asm__ __volatile__("mrs %0,ELR_EL1\n\t":"=r"(res));
        return res;
    }
    AS_MACRO RegELR_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,ELR_EL1\n\t":"=r"(*this));
        return *this;
    }
    AS_MACRO void write()const
    {
        __asm__ __volatile__("msr ELR_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegELR_EL2 
{
public:
    using ScaleType=uint64_t;
            uint64_t  returnAddr:64;
    AS_MACRO uint64_t  get()const 
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    AS_MACRO uint64_t  get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }
    
    AS_MACRO RegELR_EL2& set(uint64_t v)
    { 
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    AS_MACRO volatile RegELR_EL2 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    AS_MACRO RegELR_EL2 & setMandatoryFields()
    {
        returnAddr = 0;
        return *this;
        }
    AS_MACRO RegELR_EL2 copy()const volatile
    {
    	RegELR_EL2 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO RegELR_EL2 copy()const
    {
    	RegELR_EL2 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO void dump()const volatile
    {
        kout << "RegELR_EL2: ";
            kout
                << "returnAddr = " << Hex(returnAddr) << ", "
                << "\n";
    }
    AS_MACRO void dump()const
    {
    	reinterpret_cast<volatile const RegELR_EL2*>(this)->dump();
    }
    AS_MACRO uint64_t & asuint64_t()
    {
    	return *reinterpret_cast<uint64_t*>(this);
    }
    AS_MACRO const uint64_t & asuint64_t()const
    {
    	return *reinterpret_cast<const uint64_t*>(this);
    }
    AS_MACRO static RegELR_EL2 make(uint64_t val)
    {
        RegELR_EL2 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    AS_MACRO static RegELR_EL2 read()
    { 
        RegELR_EL2 res;
        __asm__ __volatile__("mrs %0,ELR_EL2\n\t":"=r"(res));
        return res;
    }
    AS_MACRO RegELR_EL2 & update()
    {
        __asm__ __volatile__("mrs %0,ELR_EL2\n\t":"=r"(*this));
        return *this;
    }
    AS_MACRO void write()const
    {
        __asm__ __volatile__("msr ELR_EL2,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegELR_EL3 
{
public:
    using ScaleType=uint64_t;
            uint64_t  returnAddr:64;
    AS_MACRO uint64_t  get()const 
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    AS_MACRO uint64_t  get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }
    
    AS_MACRO RegELR_EL3& set(uint64_t v)
    { 
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    AS_MACRO volatile RegELR_EL3 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    AS_MACRO RegELR_EL3 & setMandatoryFields()
    {
        returnAddr = 0;
        return *this;
        }
    AS_MACRO RegELR_EL3 copy()const volatile
    {
    	RegELR_EL3 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO RegELR_EL3 copy()const
    {
    	RegELR_EL3 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO void dump()const volatile
    {
        kout << "RegELR_EL3: ";
            kout
                << "returnAddr = " << Hex(returnAddr) << ", "
                << "\n";
    }
    AS_MACRO void dump()const
    {
    	reinterpret_cast<volatile const RegELR_EL3*>(this)->dump();
    }
    AS_MACRO uint64_t & asuint64_t()
    {
    	return *reinterpret_cast<uint64_t*>(this);
    }
    AS_MACRO const uint64_t & asuint64_t()const
    {
    	return *reinterpret_cast<const uint64_t*>(this);
    }
    AS_MACRO static RegELR_EL3 make(uint64_t val)
    {
        RegELR_EL3 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    AS_MACRO static RegELR_EL3 read()
    { 
        RegELR_EL3 res;
        __asm__ __volatile__("mrs %0,ELR_EL3\n\t":"=r"(res));
        return res;
    }
    AS_MACRO RegELR_EL3 & update()
    {
        __asm__ __volatile__("mrs %0,ELR_EL3\n\t":"=r"(*this));
        return *this;
    }
    AS_MACRO void write()const
    {
        __asm__ __volatile__("msr ELR_EL3,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegESR_EL1 
{
public:
    using ScaleType=uint32_t;
            uint32_t  ISS:25;
            uint32_t  IL:1;
            uint32_t  EC:6;
    AS_MACRO uint32_t  get()const 
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    AS_MACRO uint32_t  get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }
    
    AS_MACRO RegESR_EL1& set(uint32_t v)
    { 
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    AS_MACRO volatile RegESR_EL1 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    AS_MACRO RegESR_EL1 & setMandatoryFields()
    {
        ISS = 0;
        IL = 0;
        EC = 0;
        return *this;
        }
    AS_MACRO RegESR_EL1 copy()const volatile
    {
    	RegESR_EL1 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO RegESR_EL1 copy()const
    {
    	RegESR_EL1 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO void dump()const volatile
    {
        kout << "RegESR_EL1: ";
            kout
                << "ISS = " << Hex(ISS) << ", "
                << "IL = " << IL << ", "
                << "EC = " << Hex(EC) << ", "
                << "\n";
    }
    AS_MACRO void dump()const
    {
    	reinterpret_cast<volatile const RegESR_EL1*>(this)->dump();
    }
    AS_MACRO uint32_t & asuint32_t()
    {
    	return *reinterpret_cast<uint32_t*>(this);
    }
    AS_MACRO const uint32_t & asuint32_t()const
    {
    	return *reinterpret_cast<const uint32_t*>(this);
    }
    AS_MACRO static RegESR_EL1 make(uint32_t val)
    {
        RegESR_EL1 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    AS_MACRO static RegESR_EL1 read()
    { 
        RegESR_EL1 res;
        __asm__ __volatile__("mrs %0,ESR_EL1\n\t":"=r"(res));
        return res;
    }
    AS_MACRO RegESR_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,ESR_EL1\n\t":"=r"(*this));
        return *this;
    }
    AS_MACRO void write()const
    {
        __asm__ __volatile__("msr ESR_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegESR_EL2 
{
public:
    using ScaleType=uint32_t;
            uint32_t  ISS:25;
            uint32_t  IL:1;
            uint32_t  EC:6;
    AS_MACRO uint32_t  get()const 
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    AS_MACRO uint32_t  get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }
    
    AS_MACRO RegESR_EL2& set(uint32_t v)
    { 
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    AS_MACRO volatile RegESR_EL2 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    AS_MACRO RegESR_EL2 & setMandatoryFields()
    {
        ISS = 0;
        IL = 0;
        EC = 0;
        return *this;
        }
    AS_MACRO RegESR_EL2 copy()const volatile
    {
    	RegESR_EL2 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO RegESR_EL2 copy()const
    {
    	RegESR_EL2 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO void dump()const volatile
    {
        kout << "RegESR_EL2: ";
            kout
                << "ISS = " << Hex(ISS) << ", "
                << "IL = " << IL << ", "
                << "EC = " << Hex(EC) << ", "
                << "\n";
    }
    AS_MACRO void dump()const
    {
    	reinterpret_cast<volatile const RegESR_EL2*>(this)->dump();
    }
    AS_MACRO uint32_t & asuint32_t()
    {
    	return *reinterpret_cast<uint32_t*>(this);
    }
    AS_MACRO const uint32_t & asuint32_t()const
    {
    	return *reinterpret_cast<const uint32_t*>(this);
    }
    AS_MACRO static RegESR_EL2 make(uint32_t val)
    {
        RegESR_EL2 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    AS_MACRO static RegESR_EL2 read()
    { 
        RegESR_EL2 res;
        __asm__ __volatile__("mrs %0,ESR_EL2\n\t":"=r"(res));
        return res;
    }
    AS_MACRO RegESR_EL2 & update()
    {
        __asm__ __volatile__("mrs %0,ESR_EL2\n\t":"=r"(*this));
        return *this;
    }
    AS_MACRO void write()const
    {
        __asm__ __volatile__("msr ESR_EL2,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegESR_EL3 
{
public:
    using ScaleType=uint32_t;
            uint32_t  ISS:25;
            uint32_t  IL:1;
            uint32_t  EC:6;
    AS_MACRO uint32_t  get()const 
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    AS_MACRO uint32_t  get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }
    
    AS_MACRO RegESR_EL3& set(uint32_t v)
    { 
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    AS_MACRO volatile RegESR_EL3 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    AS_MACRO RegESR_EL3 & setMandatoryFields()
    {
        ISS = 0;
        IL = 0;
        EC = 0;
        return *this;
        }
    AS_MACRO RegESR_EL3 copy()const volatile
    {
    	RegESR_EL3 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO RegESR_EL3 copy()const
    {
    	RegESR_EL3 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO void dump()const volatile
    {
        kout << "RegESR_EL3: ";
            kout
                << "ISS = " << Hex(ISS) << ", "
                << "IL = " << IL << ", "
                << "EC = " << Hex(EC) << ", "
                << "\n";
    }
    AS_MACRO void dump()const
    {
    	reinterpret_cast<volatile const RegESR_EL3*>(this)->dump();
    }
    AS_MACRO uint32_t & asuint32_t()
    {
    	return *reinterpret_cast<uint32_t*>(this);
    }
    AS_MACRO const uint32_t & asuint32_t()const
    {
    	return *reinterpret_cast<const uint32_t*>(this);
    }
    AS_MACRO static RegESR_EL3 make(uint32_t val)
    {
        RegESR_EL3 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    AS_MACRO static RegESR_EL3 read()
    { 
        RegESR_EL3 res;
        __asm__ __volatile__("mrs %0,ESR_EL3\n\t":"=r"(res));
        return res;
    }
    AS_MACRO RegESR_EL3 & update()
    {
        __asm__ __volatile__("mrs %0,ESR_EL3\n\t":"=r"(*this));
        return *this;
    }
    AS_MACRO void write()const
    {
        __asm__ __volatile__("msr ESR_EL3,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegFAR_EL1 
{
public:
    using ScaleType=uint64_t;
            uint64_t  faultAddr:64;
    AS_MACRO uint64_t  get()const 
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    AS_MACRO uint64_t  get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }
    
    AS_MACRO RegFAR_EL1& set(uint64_t v)
    { 
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    AS_MACRO volatile RegFAR_EL1 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    AS_MACRO RegFAR_EL1 & setMandatoryFields()
    {
        faultAddr = 0;
        return *this;
        }
    AS_MACRO RegFAR_EL1 copy()const volatile
    {
    	RegFAR_EL1 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO RegFAR_EL1 copy()const
    {
    	RegFAR_EL1 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO void dump()const volatile
    {
        kout << "RegFAR_EL1: ";
            kout
                << "faultAddr = " << Hex(faultAddr) << ", "
                << "\n";
    }
    AS_MACRO void dump()const
    {
    	reinterpret_cast<volatile const RegFAR_EL1*>(this)->dump();
    }
    AS_MACRO uint64_t & asuint64_t()
    {
    	return *reinterpret_cast<uint64_t*>(this);
    }
    AS_MACRO const uint64_t & asuint64_t()const
    {
    	return *reinterpret_cast<const uint64_t*>(this);
    }
    AS_MACRO static RegFAR_EL1 make(uint64_t val)
    {
        RegFAR_EL1 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    AS_MACRO static RegFAR_EL1 read()
    { 
        RegFAR_EL1 res;
        __asm__ __volatile__("mrs %0,FAR_EL1\n\t":"=r"(res));
        return res;
    }
    AS_MACRO RegFAR_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,FAR_EL1\n\t":"=r"(*this));
        return *this;
    }
    AS_MACRO void write()const
    {
        __asm__ __volatile__("msr FAR_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegFAR_EL2 
{
public:
    using ScaleType=uint64_t;
            uint64_t  faultAddr:64;
    AS_MACRO uint64_t  get()const 
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    AS_MACRO uint64_t  get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }
    
    AS_MACRO RegFAR_EL2& set(uint64_t v)
    { 
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    AS_MACRO volatile RegFAR_EL2 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    AS_MACRO RegFAR_EL2 & setMandatoryFields()
    {
        faultAddr = 0;
        return *this;
        }
    AS_MACRO RegFAR_EL2 copy()const volatile
    {
    	RegFAR_EL2 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO RegFAR_EL2 copy()const
    {
    	RegFAR_EL2 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO void dump()const volatile
    {
        kout << "RegFAR_EL2: ";
            kout
                << "faultAddr = " << Hex(faultAddr) << ", "
                << "\n";
    }
    AS_MACRO void dump()const
    {
    	reinterpret_cast<volatile const RegFAR_EL2*>(this)->dump();
    }
    AS_MACRO uint64_t & asuint64_t()
    {
    	return *reinterpret_cast<uint64_t*>(this);
    }
    AS_MACRO const uint64_t & asuint64_t()const
    {
    	return *reinterpret_cast<const uint64_t*>(this);
    }
    AS_MACRO static RegFAR_EL2 make(uint64_t val)
    {
        RegFAR_EL2 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    AS_MACRO static RegFAR_EL2 read()
    { 
        RegFAR_EL2 res;
        __asm__ __volatile__("mrs %0,FAR_EL2\n\t":"=r"(res));
        return res;
    }
    AS_MACRO RegFAR_EL2 & update()
    {
        __asm__ __volatile__("mrs %0,FAR_EL2\n\t":"=r"(*this));
        return *this;
    }
    AS_MACRO void write()const
    {
        __asm__ __volatile__("msr FAR_EL2,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegFAR_EL3 
{
public:
    using ScaleType=uint64_t;
            uint64_t  faultAddr:64;
    AS_MACRO uint64_t  get()const 
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    AS_MACRO uint64_t  get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }
    
    AS_MACRO RegFAR_EL3& set(uint64_t v)
    { 
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    AS_MACRO volatile RegFAR_EL3 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    AS_MACRO RegFAR_EL3 & setMandatoryFields()
    {
        faultAddr = 0;
        return *this;
        }
    AS_MACRO RegFAR_EL3 copy()const volatile
    {
    	RegFAR_EL3 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO RegFAR_EL3 copy()const
    {
    	RegFAR_EL3 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO void dump()const volatile
    {
        kout << "RegFAR_EL3: ";
            kout
                << "faultAddr = " << Hex(faultAddr) << ", "
                << "\n";
    }
    AS_MACRO void dump()const
    {
    	reinterpret_cast<volatile const RegFAR_EL3*>(this)->dump();
    }
    AS_MACRO uint64_t & asuint64_t()
    {
    	return *reinterpret_cast<uint64_t*>(this);
    }
    AS_MACRO const uint64_t & asuint64_t()const
    {
    	return *reinterpret_cast<const uint64_t*>(this);
    }
    AS_MACRO static RegFAR_EL3 make(uint64_t val)
    {
        RegFAR_EL3 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    AS_MACRO static RegFAR_EL3 read()
    { 
        RegFAR_EL3 res;
        __asm__ __volatile__("mrs %0,FAR_EL3\n\t":"=r"(res));
        return res;
    }
    AS_MACRO RegFAR_EL3 & update()
    {
        __asm__ __volatile__("mrs %0,FAR_EL3\n\t":"=r"(*this));
        return *this;
    }
    AS_MACRO void write()const
    {
        __asm__ __volatile__("msr FAR_EL3,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegSPSR_EL1 
{
public:
    using ScaleType=uint32_t;
            uint32_t  SPSel:1;
            uint32_t  RES0_0:1;
            uint32_t  EL:2;
            uint32_t  ExeState:1;
            uint32_t  RES0_1:1;
            uint32_t  FIQMask:1;
            uint32_t  IRQMask:1;
            uint32_t  SErrorMask:1;
            uint32_t  DebugMask:1;
            uint32_t  RES0_2:10;
            uint32_t  IL:1;
            uint32_t  SoftwareStep:1;
            uint32_t  PAN:1;
            uint32_t  UAO:1;
            uint32_t  RES0_3:4;
            uint32_t  V:1;
            uint32_t  C:1;
            uint32_t  Z:1;
            uint32_t  N:1;
    AS_MACRO uint32_t  get()const 
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    AS_MACRO uint32_t  get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }
    
    AS_MACRO RegSPSR_EL1& set(uint32_t v)
    { 
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    AS_MACRO volatile RegSPSR_EL1 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    AS_MACRO RegSPSR_EL1 & setMandatoryFields()
    {
        SPSel = 0;
        RES0_0 = 0;
        EL = 0;
        ExeState = 0;
        RES0_1 = 0;
        FIQMask = 0;
        IRQMask = 0;
        SErrorMask = 0;
        DebugMask = 0;
        RES0_2 = 0;
        IL = 0;
        SoftwareStep = 0;
        PAN = 0;
        UAO = 0;
        RES0_3 = 0;
        V = 0;
        C = 0;
        Z = 0;
        N = 0;
        return *this;
        }
    AS_MACRO RegSPSR_EL1 copy()const volatile
    {
    	RegSPSR_EL1 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO RegSPSR_EL1 copy()const
    {
    	RegSPSR_EL1 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO void dump()const volatile
    {
        kout << "RegSPSR_EL1: ";
            kout
                << "SPSel = " << SPSel << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "EL = " << EL << ", "
                << "ExeState = " << ExeState << ", "
                << "RES0_1 = " << RES0_1 << ", "
                << "FIQMask = " << FIQMask << ", "
                << "IRQMask = " << IRQMask << ", "
                << "SErrorMask = " << SErrorMask << ", "
                << "DebugMask = " << DebugMask << ", "
                << "RES0_2 = " << RES0_2 << ", "
                << "IL = " << IL << ", "
                << "SoftwareStep = " << SoftwareStep << ", "
                << "PAN = " << PAN << ", "
                << "UAO = " << UAO << ", "
                << "RES0_3 = " << RES0_3 << ", "
                << "V = " << V << ", "
                << "C = " << C << ", "
                << "Z = " << Z << ", "
                << "N = " << N << ", "
                << "\n";
    }
    AS_MACRO void dump()const
    {
    	reinterpret_cast<volatile const RegSPSR_EL1*>(this)->dump();
    }
    AS_MACRO uint32_t & asuint32_t()
    {
    	return *reinterpret_cast<uint32_t*>(this);
    }
    AS_MACRO const uint32_t & asuint32_t()const
    {
    	return *reinterpret_cast<const uint32_t*>(this);
    }
    AS_MACRO static RegSPSR_EL1 make(uint32_t val)
    {
        RegSPSR_EL1 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    AS_MACRO static RegSPSR_EL1 read()
    { 
        RegSPSR_EL1 res;
        __asm__ __volatile__("mrs %0,SPSR_EL1\n\t":"=r"(res));
        return res;
    }
    AS_MACRO RegSPSR_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,SPSR_EL1\n\t":"=r"(*this));
        return *this;
    }
    AS_MACRO void write()const
    {
        __asm__ __volatile__("msr SPSR_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegSPSR_EL2 
{
public:
    using ScaleType=uint32_t;
            uint32_t  SPSel:1;
            uint32_t  RES0_0:1;
            uint32_t  EL:2;
            uint32_t  ExeState:1;
            uint32_t  RES0_1:1;
            uint32_t  FIQMask:1;
            uint32_t  IRQMask:1;
            uint32_t  SErrorMask:1;
            uint32_t  DebugMask:1;
            uint32_t  RES0_2:10;
            uint32_t  IL:1;
            uint32_t  SoftwareStep:1;
            uint32_t  PAN:1;
            uint32_t  UAO:1;
            uint32_t  RES0_3:4;
            uint32_t  V:1;
            uint32_t  C:1;
            uint32_t  Z:1;
            uint32_t  N:1;
    AS_MACRO uint32_t  get()const 
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    AS_MACRO uint32_t  get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }
    
    AS_MACRO RegSPSR_EL2& set(uint32_t v)
    { 
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    AS_MACRO volatile RegSPSR_EL2 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    AS_MACRO RegSPSR_EL2 & setMandatoryFields()
    {
        SPSel = 0;
        RES0_0 = 0;
        EL = 0;
        ExeState = 0;
        RES0_1 = 0;
        FIQMask = 0;
        IRQMask = 0;
        SErrorMask = 0;
        DebugMask = 0;
        RES0_2 = 0;
        IL = 0;
        SoftwareStep = 0;
        PAN = 0;
        UAO = 0;
        RES0_3 = 0;
        V = 0;
        C = 0;
        Z = 0;
        N = 0;
        return *this;
        }
    AS_MACRO RegSPSR_EL2 copy()const volatile
    {
    	RegSPSR_EL2 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO RegSPSR_EL2 copy()const
    {
    	RegSPSR_EL2 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO void dump()const volatile
    {
        kout << "RegSPSR_EL2: ";
            kout
                << "SPSel = " << SPSel << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "EL = " << EL << ", "
                << "ExeState = " << ExeState << ", "
                << "RES0_1 = " << RES0_1 << ", "
                << "FIQMask = " << FIQMask << ", "
                << "IRQMask = " << IRQMask << ", "
                << "SErrorMask = " << SErrorMask << ", "
                << "DebugMask = " << DebugMask << ", "
                << "RES0_2 = " << RES0_2 << ", "
                << "IL = " << IL << ", "
                << "SoftwareStep = " << SoftwareStep << ", "
                << "PAN = " << PAN << ", "
                << "UAO = " << UAO << ", "
                << "RES0_3 = " << RES0_3 << ", "
                << "V = " << V << ", "
                << "C = " << C << ", "
                << "Z = " << Z << ", "
                << "N = " << N << ", "
                << "\n";
    }
    AS_MACRO void dump()const
    {
    	reinterpret_cast<volatile const RegSPSR_EL2*>(this)->dump();
    }
    AS_MACRO uint32_t & asuint32_t()
    {
    	return *reinterpret_cast<uint32_t*>(this);
    }
    AS_MACRO const uint32_t & asuint32_t()const
    {
    	return *reinterpret_cast<const uint32_t*>(this);
    }
    AS_MACRO static RegSPSR_EL2 make(uint32_t val)
    {
        RegSPSR_EL2 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    AS_MACRO static RegSPSR_EL2 read()
    { 
        RegSPSR_EL2 res;
        __asm__ __volatile__("mrs %0,SPSR_EL2\n\t":"=r"(res));
        return res;
    }
    AS_MACRO RegSPSR_EL2 & update()
    {
        __asm__ __volatile__("mrs %0,SPSR_EL2\n\t":"=r"(*this));
        return *this;
    }
    AS_MACRO void write()const
    {
        __asm__ __volatile__("msr SPSR_EL2,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegSPSR_EL3 
{
public:
    using ScaleType=uint32_t;
            uint32_t  SPSel:1;
            uint32_t  RES0_0:1;
            uint32_t  EL:2;
            uint32_t  ExeState:1;
            uint32_t  RES0_1:1;
            uint32_t  FIQMask:1;
            uint32_t  IRQMask:1;
            uint32_t  SErrorMask:1;
            uint32_t  DebugMask:1;
            uint32_t  RES0_2:10;
            uint32_t  IL:1;
            uint32_t  SoftwareStep:1;
            uint32_t  PAN:1;
            uint32_t  UAO:1;
            uint32_t  RES0_3:4;
            uint32_t  V:1;
            uint32_t  C:1;
            uint32_t  Z:1;
            uint32_t  N:1;
    AS_MACRO uint32_t  get()const 
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    AS_MACRO uint32_t  get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }
    
    AS_MACRO RegSPSR_EL3& set(uint32_t v)
    { 
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    AS_MACRO volatile RegSPSR_EL3 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    AS_MACRO RegSPSR_EL3 & setMandatoryFields()
    {
        SPSel = 0;
        RES0_0 = 0;
        EL = 0;
        ExeState = 0;
        RES0_1 = 0;
        FIQMask = 0;
        IRQMask = 0;
        SErrorMask = 0;
        DebugMask = 0;
        RES0_2 = 0;
        IL = 0;
        SoftwareStep = 0;
        PAN = 0;
        UAO = 0;
        RES0_3 = 0;
        V = 0;
        C = 0;
        Z = 0;
        N = 0;
        return *this;
        }
    AS_MACRO RegSPSR_EL3 copy()const volatile
    {
    	RegSPSR_EL3 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO RegSPSR_EL3 copy()const
    {
    	RegSPSR_EL3 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO void dump()const volatile
    {
        kout << "RegSPSR_EL3: ";
            kout
                << "SPSel = " << SPSel << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "EL = " << EL << ", "
                << "ExeState = " << ExeState << ", "
                << "RES0_1 = " << RES0_1 << ", "
                << "FIQMask = " << FIQMask << ", "
                << "IRQMask = " << IRQMask << ", "
                << "SErrorMask = " << SErrorMask << ", "
                << "DebugMask = " << DebugMask << ", "
                << "RES0_2 = " << RES0_2 << ", "
                << "IL = " << IL << ", "
                << "SoftwareStep = " << SoftwareStep << ", "
                << "PAN = " << PAN << ", "
                << "UAO = " << UAO << ", "
                << "RES0_3 = " << RES0_3 << ", "
                << "V = " << V << ", "
                << "C = " << C << ", "
                << "Z = " << Z << ", "
                << "N = " << N << ", "
                << "\n";
    }
    AS_MACRO void dump()const
    {
    	reinterpret_cast<volatile const RegSPSR_EL3*>(this)->dump();
    }
    AS_MACRO uint32_t & asuint32_t()
    {
    	return *reinterpret_cast<uint32_t*>(this);
    }
    AS_MACRO const uint32_t & asuint32_t()const
    {
    	return *reinterpret_cast<const uint32_t*>(this);
    }
    AS_MACRO static RegSPSR_EL3 make(uint32_t val)
    {
        RegSPSR_EL3 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    AS_MACRO static RegSPSR_EL3 read()
    { 
        RegSPSR_EL3 res;
        __asm__ __volatile__("mrs %0,SPSR_EL3\n\t":"=r"(res));
        return res;
    }
    AS_MACRO RegSPSR_EL3 & update()
    {
        __asm__ __volatile__("mrs %0,SPSR_EL3\n\t":"=r"(*this));
        return *this;
    }
    AS_MACRO void write()const
    {
        __asm__ __volatile__("msr SPSR_EL3,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegSP_EL0 
{
public:
    using ScaleType=uint64_t;
            uint64_t  SP:64;
    AS_MACRO uint64_t  get()const 
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    AS_MACRO uint64_t  get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }
    
    AS_MACRO RegSP_EL0& set(uint64_t v)
    { 
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    AS_MACRO volatile RegSP_EL0 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    AS_MACRO RegSP_EL0 & setMandatoryFields()
    {
        SP = 0;
        return *this;
        }
    AS_MACRO RegSP_EL0 copy()const volatile
    {
    	RegSP_EL0 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO RegSP_EL0 copy()const
    {
    	RegSP_EL0 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO void dump()const volatile
    {
        kout << "RegSP_EL0: ";
            kout
                << "SP = " << SP << ", "
                << "\n";
    }
    AS_MACRO void dump()const
    {
    	reinterpret_cast<volatile const RegSP_EL0*>(this)->dump();
    }
    AS_MACRO uint64_t & asuint64_t()
    {
    	return *reinterpret_cast<uint64_t*>(this);
    }
    AS_MACRO const uint64_t & asuint64_t()const
    {
    	return *reinterpret_cast<const uint64_t*>(this);
    }
    AS_MACRO static RegSP_EL0 make(uint64_t val)
    {
        RegSP_EL0 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    AS_MACRO static RegSP_EL0 read()
    { 
        RegSP_EL0 res;
        __asm__ __volatile__("mrs %0,SP_EL0\n\t":"=r"(res));
        return res;
    }
    AS_MACRO RegSP_EL0 & update()
    {
        __asm__ __volatile__("mrs %0,SP_EL0\n\t":"=r"(*this));
        return *this;
    }
    AS_MACRO void write()const
    {
        __asm__ __volatile__("msr SP_EL0,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegSP_EL1 
{
public:
    using ScaleType=uint64_t;
            uint64_t  SP:64;
    AS_MACRO uint64_t  get()const 
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    AS_MACRO uint64_t  get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }
    
    AS_MACRO RegSP_EL1& set(uint64_t v)
    { 
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    AS_MACRO volatile RegSP_EL1 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    AS_MACRO RegSP_EL1 & setMandatoryFields()
    {
        SP = 0;
        return *this;
        }
    AS_MACRO RegSP_EL1 copy()const volatile
    {
    	RegSP_EL1 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO RegSP_EL1 copy()const
    {
    	RegSP_EL1 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO void dump()const volatile
    {
        kout << "RegSP_EL1: ";
            kout
                << "SP = " << SP << ", "
                << "\n";
    }
    AS_MACRO void dump()const
    {
    	reinterpret_cast<volatile const RegSP_EL1*>(this)->dump();
    }
    AS_MACRO uint64_t & asuint64_t()
    {
    	return *reinterpret_cast<uint64_t*>(this);
    }
    AS_MACRO const uint64_t & asuint64_t()const
    {
    	return *reinterpret_cast<const uint64_t*>(this);
    }
    AS_MACRO static RegSP_EL1 make(uint64_t val)
    {
        RegSP_EL1 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    AS_MACRO static RegSP_EL1 read()
    { 
        RegSP_EL1 res;
        __asm__ __volatile__("mrs %0,SP_EL1\n\t":"=r"(res));
        return res;
    }
    AS_MACRO RegSP_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,SP_EL1\n\t":"=r"(*this));
        return *this;
    }
    AS_MACRO void write()const
    {
        __asm__ __volatile__("msr SP_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegSP_EL2 
{
public:
    using ScaleType=uint64_t;
            uint64_t  SP:64;
    AS_MACRO uint64_t  get()const 
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    AS_MACRO uint64_t  get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }
    
    AS_MACRO RegSP_EL2& set(uint64_t v)
    { 
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    AS_MACRO volatile RegSP_EL2 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    AS_MACRO RegSP_EL2 & setMandatoryFields()
    {
        SP = 0;
        return *this;
        }
    AS_MACRO RegSP_EL2 copy()const volatile
    {
    	RegSP_EL2 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO RegSP_EL2 copy()const
    {
    	RegSP_EL2 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO void dump()const volatile
    {
        kout << "RegSP_EL2: ";
            kout
                << "SP = " << SP << ", "
                << "\n";
    }
    AS_MACRO void dump()const
    {
    	reinterpret_cast<volatile const RegSP_EL2*>(this)->dump();
    }
    AS_MACRO uint64_t & asuint64_t()
    {
    	return *reinterpret_cast<uint64_t*>(this);
    }
    AS_MACRO const uint64_t & asuint64_t()const
    {
    	return *reinterpret_cast<const uint64_t*>(this);
    }
    AS_MACRO static RegSP_EL2 make(uint64_t val)
    {
        RegSP_EL2 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    AS_MACRO static RegSP_EL2 read()
    { 
        RegSP_EL2 res;
        __asm__ __volatile__("mrs %0,SP_EL2\n\t":"=r"(res));
        return res;
    }
    AS_MACRO RegSP_EL2 & update()
    {
        __asm__ __volatile__("mrs %0,SP_EL2\n\t":"=r"(*this));
        return *this;
    }
    AS_MACRO void write()const
    {
        __asm__ __volatile__("msr SP_EL2,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegSP_EL3 
{
public:
    using ScaleType=uint64_t;
            uint64_t  SP:64;
    AS_MACRO uint64_t  get()const 
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    AS_MACRO uint64_t  get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }
    
    AS_MACRO RegSP_EL3& set(uint64_t v)
    { 
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    AS_MACRO volatile RegSP_EL3 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    AS_MACRO RegSP_EL3 & setMandatoryFields()
    {
        SP = 0;
        return *this;
        }
    AS_MACRO RegSP_EL3 copy()const volatile
    {
    	RegSP_EL3 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO RegSP_EL3 copy()const
    {
    	RegSP_EL3 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO void dump()const volatile
    {
        kout << "RegSP_EL3: ";
            kout
                << "SP = " << SP << ", "
                << "\n";
    }
    AS_MACRO void dump()const
    {
    	reinterpret_cast<volatile const RegSP_EL3*>(this)->dump();
    }
    AS_MACRO uint64_t & asuint64_t()
    {
    	return *reinterpret_cast<uint64_t*>(this);
    }
    AS_MACRO const uint64_t & asuint64_t()const
    {
    	return *reinterpret_cast<const uint64_t*>(this);
    }
    AS_MACRO static RegSP_EL3 make(uint64_t val)
    {
        RegSP_EL3 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    AS_MACRO static RegSP_EL3 read()
    { 
        RegSP_EL3 res;
        __asm__ __volatile__("mrs %0,SP_EL3\n\t":"=r"(res));
        return res;
    }
    AS_MACRO RegSP_EL3 & update()
    {
        __asm__ __volatile__("mrs %0,SP_EL3\n\t":"=r"(*this));
        return *this;
    }
    AS_MACRO void write()const
    {
        __asm__ __volatile__("msr SP_EL3,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegNZCV 
{
public:
    using ScaleType=uint64_t;
            uint64_t  RES0_0:28;
            uint64_t  V:1;
            uint64_t  C:1;
            uint64_t  Z:1;
            uint64_t  N:1;
    AS_MACRO uint64_t  get()const 
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    AS_MACRO uint64_t  get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }
    
    AS_MACRO RegNZCV& set(uint64_t v)
    { 
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    AS_MACRO volatile RegNZCV & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    AS_MACRO RegNZCV & setMandatoryFields()
    {
        RES0_0 = 0;
        V = 0;
        C = 0;
        Z = 0;
        N = 0;
        return *this;
        }
    AS_MACRO RegNZCV copy()const volatile
    {
    	RegNZCV res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO RegNZCV copy()const
    {
    	RegNZCV res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO void dump()const volatile
    {
        kout << "RegNZCV: ";
            kout
                << "RES0_0 = " << RES0_0 << ", "
                << "V = " << V << ", "
                << "C = " << C << ", "
                << "Z = " << Z << ", "
                << "N = " << N << ", "
                << "\n";
    }
    AS_MACRO void dump()const
    {
    	reinterpret_cast<volatile const RegNZCV*>(this)->dump();
    }
    AS_MACRO uint64_t & asuint64_t()
    {
    	return *reinterpret_cast<uint64_t*>(this);
    }
    AS_MACRO const uint64_t & asuint64_t()const
    {
    	return *reinterpret_cast<const uint64_t*>(this);
    }
    AS_MACRO static RegNZCV make(uint64_t val)
    {
        RegNZCV res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    AS_MACRO static RegNZCV read()
    { 
        RegNZCV res;
        __asm__ __volatile__("mrs %0,NZCV\n\t":"=r"(res));
        return res;
    }
    AS_MACRO RegNZCV & update()
    {
        __asm__ __volatile__("mrs %0,NZCV\n\t":"=r"(*this));
        return *this;
    }
    AS_MACRO void write()const
    {
        __asm__ __volatile__("msr NZCV,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegPAN 
{
public:
    using ScaleType=uint32_t;
            uint32_t  RES0_0:22;
            uint32_t  PAN:1;
            uint32_t  RES0_1:9;
    AS_MACRO uint32_t  get()const 
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    AS_MACRO uint32_t  get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }
    
    AS_MACRO RegPAN& set(uint32_t v)
    { 
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    AS_MACRO volatile RegPAN & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    AS_MACRO RegPAN & setMandatoryFields()
    {
        RES0_0 = 0;
        PAN = 0;
        RES0_1 = 0;
        return *this;
        }
    AS_MACRO RegPAN copy()const volatile
    {
    	RegPAN res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO RegPAN copy()const
    {
    	RegPAN res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO void dump()const volatile
    {
        kout << "RegPAN: ";
            kout
                << "RES0_0 = " << RES0_0 << ", "
                << "PAN = " << PAN << ", "
                << "RES0_1 = " << RES0_1 << ", "
                << "\n";
    }
    AS_MACRO void dump()const
    {
    	reinterpret_cast<volatile const RegPAN*>(this)->dump();
    }
    AS_MACRO uint32_t & asuint32_t()
    {
    	return *reinterpret_cast<uint32_t*>(this);
    }
    AS_MACRO const uint32_t & asuint32_t()const
    {
    	return *reinterpret_cast<const uint32_t*>(this);
    }
    AS_MACRO static RegPAN make(uint32_t val)
    {
        RegPAN res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    AS_MACRO static RegPAN read()
    { 
        RegPAN res;
        __asm__ __volatile__("mrs %0,PAN\n\t":"=r"(res));
        return res;
    }
    AS_MACRO RegPAN & update()
    {
        __asm__ __volatile__("mrs %0,PAN\n\t":"=r"(*this));
        return *this;
    }
    AS_MACRO void write()const
    {
        __asm__ __volatile__("msr PAN,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegSPSel 
{
public:
    using ScaleType=uint32_t;
            uint32_t  SP:1;
            uint32_t  RES0_0:31;
    AS_MACRO uint32_t  get()const 
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    AS_MACRO uint32_t  get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }
    
    AS_MACRO RegSPSel& set(uint32_t v)
    { 
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    AS_MACRO volatile RegSPSel & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    AS_MACRO RegSPSel & setMandatoryFields()
    {
        SP = 0;
        RES0_0 = 0;
        return *this;
        }
    AS_MACRO RegSPSel copy()const volatile
    {
    	RegSPSel res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO RegSPSel copy()const
    {
    	RegSPSel res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO void dump()const volatile
    {
        kout << "RegSPSel: ";
            kout
                << "SP = " << SP << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "\n";
    }
    AS_MACRO void dump()const
    {
    	reinterpret_cast<volatile const RegSPSel*>(this)->dump();
    }
    AS_MACRO uint32_t & asuint32_t()
    {
    	return *reinterpret_cast<uint32_t*>(this);
    }
    AS_MACRO const uint32_t & asuint32_t()const
    {
    	return *reinterpret_cast<const uint32_t*>(this);
    }
    AS_MACRO static RegSPSel make(uint32_t val)
    {
        RegSPSel res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    AS_MACRO static RegSPSel read()
    { 
        RegSPSel res;
        __asm__ __volatile__("mrs %0,SPSel\n\t":"=r"(res));
        return res;
    }
    AS_MACRO RegSPSel & update()
    {
        __asm__ __volatile__("mrs %0,SPSel\n\t":"=r"(*this));
        return *this;
    }
    AS_MACRO void write()const
    {
        __asm__ __volatile__("msr SPSel,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegUAO 
{
public:
    using ScaleType=uint64_t;
            uint64_t  RES0_0:23;
            uint64_t  UAO:1;
            uint64_t  RES0_1:8;
    AS_MACRO uint64_t  get()const 
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    AS_MACRO uint64_t  get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }
    
    AS_MACRO RegUAO& set(uint64_t v)
    { 
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    AS_MACRO volatile RegUAO & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    AS_MACRO RegUAO & setMandatoryFields()
    {
        RES0_0 = 0;
        UAO = 0;
        RES0_1 = 0;
        return *this;
        }
    AS_MACRO RegUAO copy()const volatile
    {
    	RegUAO res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO RegUAO copy()const
    {
    	RegUAO res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO void dump()const volatile
    {
        kout << "RegUAO: ";
            kout
                << "RES0_0 = " << RES0_0 << ", "
                << "UAO = " << UAO << ", "
                << "RES0_1 = " << RES0_1 << ", "
                << "\n";
    }
    AS_MACRO void dump()const
    {
    	reinterpret_cast<volatile const RegUAO*>(this)->dump();
    }
    AS_MACRO uint64_t & asuint64_t()
    {
    	return *reinterpret_cast<uint64_t*>(this);
    }
    AS_MACRO const uint64_t & asuint64_t()const
    {
    	return *reinterpret_cast<const uint64_t*>(this);
    }
    AS_MACRO static RegUAO make(uint64_t val)
    {
        RegUAO res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    AS_MACRO static RegUAO read()
    { 
        RegUAO res;
        __asm__ __volatile__("mrs %0,UAO\n\t":"=r"(res));
        return res;
    }
    AS_MACRO RegUAO & update()
    {
        __asm__ __volatile__("mrs %0,UAO\n\t":"=r"(*this));
        return *this;
    }
    AS_MACRO void write()const
    {
        __asm__ __volatile__("msr UAO,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegPC 
{
public:
    using ScaleType=uint64_t;
            uint64_t  PC:64;
    AS_MACRO uint64_t  get()const 
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    AS_MACRO uint64_t  get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }
    
    AS_MACRO RegPC& set(uint64_t v)
    { 
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    AS_MACRO volatile RegPC & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    AS_MACRO RegPC & setMandatoryFields()
    {
        PC = 0;
        return *this;
        }
    AS_MACRO RegPC copy()const volatile
    {
    	RegPC res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO RegPC copy()const
    {
    	RegPC res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO void dump()const volatile
    {
        kout << "RegPC: ";
            kout
                << "PC = " << Hex(PC) << ", "
                << "\n";
    }
    AS_MACRO void dump()const
    {
    	reinterpret_cast<volatile const RegPC*>(this)->dump();
    }
    AS_MACRO uint64_t & asuint64_t()
    {
    	return *reinterpret_cast<uint64_t*>(this);
    }
    AS_MACRO const uint64_t & asuint64_t()const
    {
    	return *reinterpret_cast<const uint64_t*>(this);
    }
    AS_MACRO static RegPC make(uint64_t val)
    {
        RegPC res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    AS_MACRO static RegPC read()
    { 
        RegPC res;
        __asm__ __volatile__("mrs %0,PC\n\t":"=r"(res));
        return res;
    }
    AS_MACRO RegPC & update()
    {
        __asm__ __volatile__("mrs %0,PC\n\t":"=r"(*this));
        return *this;
    }
    AS_MACRO void write()const
    {
        __asm__ __volatile__("msr PC,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegTCR_EL1 
{
public:
    using ScaleType=uint64_t;
            uint64_t  T0SZ:6;
            uint64_t  RES0_0:1;
            uint64_t  EPD0:1;
            uint64_t  IRGN0:2;
            uint64_t  ORGN0:2;
            uint64_t  SH0:2;
            uint64_t  TG0:2;
            uint64_t  T1SZ:6;
            uint64_t  A1:1;
            uint64_t  EPD1:1;
            uint64_t  IRGN1:2;
            uint64_t  ORGN1:2;
            uint64_t  SH1:2;
            uint64_t  TG1:2;
            uint64_t  IPS:3;
            uint64_t  RES0_1:1;
            uint64_t  AS:1;
            uint64_t  TBI0:1;
            uint64_t  TBI1:1;
            uint64_t  HA:1;
            uint64_t  HD:1;
            uint64_t  HPD0:1;
            uint64_t  HPD1:1;
            uint64_t  HWU059:1;
            uint64_t  HWU060:1;
            uint64_t  HWU061:1;
            uint64_t  HWU062:1;
            uint64_t  HWU159:1;
            uint64_t  HWU160:1;
            uint64_t  HWU161:1;
            uint64_t  HWU162:1;
            uint64_t  RES0_2:2;
            uint64_t  NFD0:1;
            uint64_t  NFD1:1;
            uint64_t  RES0_3:9;
    AS_MACRO uint64_t  get()const 
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    AS_MACRO uint64_t  get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }
    
    AS_MACRO RegTCR_EL1& set(uint64_t v)
    { 
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    AS_MACRO volatile RegTCR_EL1 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    AS_MACRO RegTCR_EL1 & setMandatoryFields()
    {
        T0SZ = 0;
        RES0_0 = 0;
        EPD0 = 0;
        IRGN0 = 0;
        ORGN0 = 0;
        SH0 = 0;
        TG0 = 0;
        T1SZ = 0;
        A1 = 0;
        EPD1 = 0;
        IRGN1 = 0;
        ORGN1 = 0;
        SH1 = 0;
        TG1 = 0;
        IPS = 0;
        RES0_1 = 0;
        AS = 0;
        TBI0 = 0;
        TBI1 = 0;
        HA = 0;
        HD = 0;
        HPD0 = 0;
        HPD1 = 0;
        HWU059 = 0;
        HWU060 = 0;
        HWU061 = 0;
        HWU062 = 0;
        HWU159 = 0;
        HWU160 = 0;
        HWU161 = 0;
        HWU162 = 0;
        RES0_2 = 0;
        NFD0 = 0;
        NFD1 = 0;
        RES0_3 = 0;
        return *this;
        }
    AS_MACRO RegTCR_EL1 copy()const volatile
    {
    	RegTCR_EL1 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO RegTCR_EL1 copy()const
    {
    	RegTCR_EL1 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO void dump()const volatile
    {
        kout << "RegTCR_EL1: ";
            kout
                << "T0SZ = " << T0SZ << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "EPD0 = " << EPD0 << ", "
                << "IRGN0 = " << IRGN0 << ", "
                << "ORGN0 = " << ORGN0 << ", "
                << "SH0 = " << SH0 << ", "
                << "TG0 = " << TG0 << ", "
                << "T1SZ = " << T1SZ << ", "
                << "A1 = " << A1 << ", "
                << "EPD1 = " << EPD1 << ", "
                << "IRGN1 = " << IRGN1 << ", "
                << "ORGN1 = " << ORGN1 << ", "
                << "SH1 = " << SH1 << ", "
                << "TG1 = " << TG1 << ", "
                << "IPS = " << IPS << ", "
                << "RES0_1 = " << RES0_1 << ", "
                << "AS = " << AS << ", "
                << "TBI0 = " << TBI0 << ", "
                << "TBI1 = " << TBI1 << ", "
                << "HA = " << HA << ", "
                << "HD = " << HD << ", "
                << "HPD0 = " << HPD0 << ", "
                << "HPD1 = " << HPD1 << ", "
                << "HWU059 = " << HWU059 << ", "
                << "HWU060 = " << HWU060 << ", "
                << "HWU061 = " << HWU061 << ", "
                << "HWU062 = " << HWU062 << ", "
                << "HWU159 = " << HWU159 << ", "
                << "HWU160 = " << HWU160 << ", "
                << "HWU161 = " << HWU161 << ", "
                << "HWU162 = " << HWU162 << ", "
                << "RES0_2 = " << RES0_2 << ", "
                << "NFD0 = " << NFD0 << ", "
                << "NFD1 = " << NFD1 << ", "
                << "RES0_3 = " << RES0_3 << ", "
                << "\n";
    }
    AS_MACRO void dump()const
    {
    	reinterpret_cast<volatile const RegTCR_EL1*>(this)->dump();
    }
    AS_MACRO uint64_t & asuint64_t()
    {
    	return *reinterpret_cast<uint64_t*>(this);
    }
    AS_MACRO const uint64_t & asuint64_t()const
    {
    	return *reinterpret_cast<const uint64_t*>(this);
    }
    AS_MACRO static RegTCR_EL1 make(uint64_t val)
    {
        RegTCR_EL1 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    AS_MACRO static RegTCR_EL1 read()
    { 
        RegTCR_EL1 res;
        __asm__ __volatile__("mrs %0,TCR_EL1\n\t":"=r"(res));
        return res;
    }
    AS_MACRO RegTCR_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,TCR_EL1\n\t":"=r"(*this));
        return *this;
    }
    AS_MACRO void write()const
    {
        __asm__ __volatile__("msr TCR_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegISR_EL1 
{
public:
    using ScaleType=uint32_t;
            uint32_t  RES0_0:6;
            uint32_t  F:1;
            uint32_t  I:1;
            uint32_t  A:1;
            uint32_t  RES0_1:23;
    AS_MACRO uint32_t  get()const 
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    AS_MACRO uint32_t  get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }
    
    AS_MACRO RegISR_EL1& set(uint32_t v)
    { 
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    AS_MACRO volatile RegISR_EL1 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    AS_MACRO RegISR_EL1 & setMandatoryFields()
    {
        RES0_0 = 0;
        F = 0;
        I = 0;
        A = 0;
        RES0_1 = 0;
        return *this;
        }
    AS_MACRO RegISR_EL1 copy()const volatile
    {
    	RegISR_EL1 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO RegISR_EL1 copy()const
    {
    	RegISR_EL1 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO void dump()const volatile
    {
        kout << "RegISR_EL1: ";
            kout
                << "RES0_0 = " << RES0_0 << ", "
                << "F = " << F << ", "
                << "I = " << I << ", "
                << "A = " << A << ", "
                << "RES0_1 = " << RES0_1 << ", "
                << "\n";
    }
    AS_MACRO void dump()const
    {
    	reinterpret_cast<volatile const RegISR_EL1*>(this)->dump();
    }
    AS_MACRO uint32_t & asuint32_t()
    {
    	return *reinterpret_cast<uint32_t*>(this);
    }
    AS_MACRO const uint32_t & asuint32_t()const
    {
    	return *reinterpret_cast<const uint32_t*>(this);
    }
    AS_MACRO static RegISR_EL1 make(uint32_t val)
    {
        RegISR_EL1 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    AS_MACRO static RegISR_EL1 read()
    { 
        RegISR_EL1 res;
        __asm__ __volatile__("mrs %0,ISR_EL1\n\t":"=r"(res));
        return res;
    }
    AS_MACRO RegISR_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,ISR_EL1\n\t":"=r"(*this));
        return *this;
    }
    AS_MACRO void write()const
    {
        __asm__ __volatile__("msr ISR_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegID_AA64ISAR0_EL1 
{
public:
    using ScaleType=uint64_t;
            uint64_t  RES0_0:4;
            uint64_t  AES:4;
            uint64_t  SHA1:4;
            uint64_t  SHA2:4;
            uint64_t  CRC32:4;
            uint64_t  Atomic:4;
            uint64_t  RES0_1:4;
            uint64_t  RDM:4;
            uint64_t  SHA3:4;
            uint64_t  SM3:4;
            uint64_t  SM4:4;
            uint64_t  DP:4;
            uint64_t  RES0_2:16;
    AS_MACRO uint64_t  get()const 
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    AS_MACRO uint64_t  get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }
    
    AS_MACRO RegID_AA64ISAR0_EL1& set(uint64_t v)
    { 
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    AS_MACRO volatile RegID_AA64ISAR0_EL1 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    AS_MACRO RegID_AA64ISAR0_EL1 & setMandatoryFields()
    {
        RES0_0 = 0;
        AES = 0;
        SHA1 = 0;
        SHA2 = 0;
        CRC32 = 0;
        Atomic = 0;
        RES0_1 = 0;
        RDM = 0;
        SHA3 = 0;
        SM3 = 0;
        SM4 = 0;
        DP = 0;
        RES0_2 = 0;
        return *this;
        }
    AS_MACRO RegID_AA64ISAR0_EL1 copy()const volatile
    {
    	RegID_AA64ISAR0_EL1 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO RegID_AA64ISAR0_EL1 copy()const
    {
    	RegID_AA64ISAR0_EL1 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO void dump()const volatile
    {
        kout << "RegID_AA64ISAR0_EL1: ";
            kout
                << "RES0_0 = " << RES0_0 << ", "
                << "AES = " << AES << ", "
                << "SHA1 = " << SHA1 << ", "
                << "SHA2 = " << SHA2 << ", "
                << "CRC32 = " << CRC32 << ", "
                << "Atomic = " << Atomic << ", "
                << "RES0_1 = " << RES0_1 << ", "
                << "RDM = " << RDM << ", "
                << "SHA3 = " << SHA3 << ", "
                << "SM3 = " << SM3 << ", "
                << "SM4 = " << SM4 << ", "
                << "DP = " << DP << ", "
                << "RES0_2 = " << RES0_2 << ", "
                << "\n";
    }
    AS_MACRO void dump()const
    {
    	reinterpret_cast<volatile const RegID_AA64ISAR0_EL1*>(this)->dump();
    }
    AS_MACRO uint64_t & asuint64_t()
    {
    	return *reinterpret_cast<uint64_t*>(this);
    }
    AS_MACRO const uint64_t & asuint64_t()const
    {
    	return *reinterpret_cast<const uint64_t*>(this);
    }
    AS_MACRO static RegID_AA64ISAR0_EL1 make(uint64_t val)
    {
        RegID_AA64ISAR0_EL1 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    AS_MACRO static RegID_AA64ISAR0_EL1 read()
    { 
        RegID_AA64ISAR0_EL1 res;
        __asm__ __volatile__("mrs %0,ID_AA64ISAR0_EL1\n\t":"=r"(res));
        return res;
    }
    AS_MACRO RegID_AA64ISAR0_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,ID_AA64ISAR0_EL1\n\t":"=r"(*this));
        return *this;
    }
    AS_MACRO void write()const
    {
        __asm__ __volatile__("msr ID_AA64ISAR0_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegCONTEXTIDR_EL1 
{
public:
    using ScaleType=uint32_t;
            uint32_t  PROCID:32;
    AS_MACRO uint32_t  get()const 
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    AS_MACRO uint32_t  get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }
    
    AS_MACRO RegCONTEXTIDR_EL1& set(uint32_t v)
    { 
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    AS_MACRO volatile RegCONTEXTIDR_EL1 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    AS_MACRO RegCONTEXTIDR_EL1 & setMandatoryFields()
    {
        PROCID = 0;
        return *this;
        }
    AS_MACRO RegCONTEXTIDR_EL1 copy()const volatile
    {
    	RegCONTEXTIDR_EL1 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO RegCONTEXTIDR_EL1 copy()const
    {
    	RegCONTEXTIDR_EL1 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO void dump()const volatile
    {
        kout << "RegCONTEXTIDR_EL1: ";
            kout
                << "PROCID = " << PROCID << ", "
                << "\n";
    }
    AS_MACRO void dump()const
    {
    	reinterpret_cast<volatile const RegCONTEXTIDR_EL1*>(this)->dump();
    }
    AS_MACRO uint32_t & asuint32_t()
    {
    	return *reinterpret_cast<uint32_t*>(this);
    }
    AS_MACRO const uint32_t & asuint32_t()const
    {
    	return *reinterpret_cast<const uint32_t*>(this);
    }
    AS_MACRO static RegCONTEXTIDR_EL1 make(uint32_t val)
    {
        RegCONTEXTIDR_EL1 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    AS_MACRO static RegCONTEXTIDR_EL1 read()
    { 
        RegCONTEXTIDR_EL1 res;
        __asm__ __volatile__("mrs %0,CONTEXTIDR_EL1\n\t":"=r"(res));
        return res;
    }
    AS_MACRO RegCONTEXTIDR_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,CONTEXTIDR_EL1\n\t":"=r"(*this));
        return *this;
    }
    AS_MACRO void write()const
    {
        __asm__ __volatile__("msr CONTEXTIDR_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegID_AA64PFR0_EL1 
{
public:
    using ScaleType=uint64_t;
            uint64_t  EL0:4;
            uint64_t  EL1:4;
            uint64_t  EL2:4;
            uint64_t  EL3:4;
            uint64_t  FP:4;
            uint64_t  AdvSIMD:4;
            uint64_t  GIC:4;
            uint64_t  RAS:4;
            uint64_t  SVE:4;
            uint64_t  RES0_0:28;
    AS_MACRO uint64_t  get()const 
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    AS_MACRO uint64_t  get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }
    
    AS_MACRO RegID_AA64PFR0_EL1& set(uint64_t v)
    { 
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    AS_MACRO volatile RegID_AA64PFR0_EL1 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    AS_MACRO RegID_AA64PFR0_EL1 & setMandatoryFields()
    {
        EL0 = 0;
        EL1 = 0;
        EL2 = 0;
        EL3 = 0;
        FP = 0;
        AdvSIMD = 0;
        GIC = 0;
        RAS = 0;
        SVE = 0;
        RES0_0 = 0;
        return *this;
        }
    AS_MACRO RegID_AA64PFR0_EL1 copy()const volatile
    {
    	RegID_AA64PFR0_EL1 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO RegID_AA64PFR0_EL1 copy()const
    {
    	RegID_AA64PFR0_EL1 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO void dump()const volatile
    {
        kout << "RegID_AA64PFR0_EL1: ";
            kout
                << "EL0 = " << EL0 << ", "
                << "EL1 = " << EL1 << ", "
                << "EL2 = " << EL2 << ", "
                << "EL3 = " << EL3 << ", "
                << "FP = " << FP << ", "
                << "AdvSIMD = " << AdvSIMD << ", "
                << "GIC = " << GIC << ", "
                << "RAS = " << RAS << ", "
                << "SVE = " << SVE << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "\n";
    }
    AS_MACRO void dump()const
    {
    	reinterpret_cast<volatile const RegID_AA64PFR0_EL1*>(this)->dump();
    }
    AS_MACRO uint64_t & asuint64_t()
    {
    	return *reinterpret_cast<uint64_t*>(this);
    }
    AS_MACRO const uint64_t & asuint64_t()const
    {
    	return *reinterpret_cast<const uint64_t*>(this);
    }
    AS_MACRO static RegID_AA64PFR0_EL1 make(uint64_t val)
    {
        RegID_AA64PFR0_EL1 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    AS_MACRO static RegID_AA64PFR0_EL1 read()
    { 
        RegID_AA64PFR0_EL1 res;
        __asm__ __volatile__("mrs %0,ID_AA64PFR0_EL1\n\t":"=r"(res));
        return res;
    }
    AS_MACRO RegID_AA64PFR0_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,ID_AA64PFR0_EL1\n\t":"=r"(*this));
        return *this;
    }
    AS_MACRO void write()const
    {
        __asm__ __volatile__("msr ID_AA64PFR0_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegID_AA64MMFR1_EL1 
{
public:
    using ScaleType=uint64_t;
            uint64_t  HAFDBS:4;
            uint64_t  VMIDBits:4;
            uint64_t  VH:4;
            uint64_t  HPDS:4;
            uint64_t  LO:4;
            uint64_t  PAN:4;
            uint64_t  SpecSEI:4;
            uint64_t  XNX:4;
            uint64_t  RES0_0:32;
    AS_MACRO uint64_t  get()const 
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    AS_MACRO uint64_t  get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }
    
    AS_MACRO RegID_AA64MMFR1_EL1& set(uint64_t v)
    { 
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    AS_MACRO volatile RegID_AA64MMFR1_EL1 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    AS_MACRO RegID_AA64MMFR1_EL1 & setMandatoryFields()
    {
        HAFDBS = 0;
        VMIDBits = 0;
        VH = 0;
        HPDS = 0;
        LO = 0;
        PAN = 0;
        SpecSEI = 0;
        XNX = 0;
        RES0_0 = 0;
        return *this;
        }
    AS_MACRO RegID_AA64MMFR1_EL1 copy()const volatile
    {
    	RegID_AA64MMFR1_EL1 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO RegID_AA64MMFR1_EL1 copy()const
    {
    	RegID_AA64MMFR1_EL1 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO void dump()const volatile
    {
        kout << "RegID_AA64MMFR1_EL1: ";
            kout
                << "HAFDBS = " << HAFDBS << ", "
                << "VMIDBits = " << VMIDBits << ", "
                << "VH = " << VH << ", "
                << "HPDS = " << HPDS << ", "
                << "LO = " << LO << ", "
                << "PAN = " << PAN << ", "
                << "SpecSEI = " << SpecSEI << ", "
                << "XNX = " << XNX << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "\n";
    }
    AS_MACRO void dump()const
    {
    	reinterpret_cast<volatile const RegID_AA64MMFR1_EL1*>(this)->dump();
    }
    AS_MACRO uint64_t & asuint64_t()
    {
    	return *reinterpret_cast<uint64_t*>(this);
    }
    AS_MACRO const uint64_t & asuint64_t()const
    {
    	return *reinterpret_cast<const uint64_t*>(this);
    }
    AS_MACRO static RegID_AA64MMFR1_EL1 make(uint64_t val)
    {
        RegID_AA64MMFR1_EL1 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    AS_MACRO static RegID_AA64MMFR1_EL1 read()
    { 
        RegID_AA64MMFR1_EL1 res;
        __asm__ __volatile__("mrs %0,ID_AA64MMFR1_EL1\n\t":"=r"(res));
        return res;
    }
    AS_MACRO RegID_AA64MMFR1_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,ID_AA64MMFR1_EL1\n\t":"=r"(*this));
        return *this;
    }
    AS_MACRO void write()const
    {
        __asm__ __volatile__("msr ID_AA64MMFR1_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegID_AA64MMFR0_EL1 
{
public:
    using ScaleType=uint64_t;
            uint64_t  PARange:4;
            uint64_t  ASIDBits:4;
            uint64_t  BigEnd:4;
            uint64_t  SNSMem:4;
            uint64_t  BigEndEL0:4;
            uint64_t  TGran16:4;
            uint64_t  TGran64:4;
            uint64_t  TGran4:4;
            uint64_t  RES0_0:32;
    AS_MACRO uint64_t  get()const 
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    AS_MACRO uint64_t  get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }
    
    AS_MACRO RegID_AA64MMFR0_EL1& set(uint64_t v)
    { 
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    AS_MACRO volatile RegID_AA64MMFR0_EL1 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    AS_MACRO RegID_AA64MMFR0_EL1 & setMandatoryFields()
    {
        PARange = 0;
        ASIDBits = 0;
        BigEnd = 0;
        SNSMem = 0;
        BigEndEL0 = 0;
        TGran16 = 0;
        TGran64 = 0;
        TGran4 = 0;
        RES0_0 = 0;
        return *this;
        }
    AS_MACRO RegID_AA64MMFR0_EL1 copy()const volatile
    {
    	RegID_AA64MMFR0_EL1 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO RegID_AA64MMFR0_EL1 copy()const
    {
    	RegID_AA64MMFR0_EL1 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO void dump()const volatile
    {
        kout << "RegID_AA64MMFR0_EL1: ";
            kout
                << "PARange = " << PARange << ", "
                << "ASIDBits = " << ASIDBits << ", "
                << "BigEnd = " << BigEnd << ", "
                << "SNSMem = " << SNSMem << ", "
                << "BigEndEL0 = " << BigEndEL0 << ", "
                << "TGran16 = " << Hex(TGran16) << ", "
                << "TGran64 = " << Hex(TGran64) << ", "
                << "TGran4 = " << Hex(TGran4) << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "\n";
    }
    AS_MACRO void dump()const
    {
    	reinterpret_cast<volatile const RegID_AA64MMFR0_EL1*>(this)->dump();
    }
    AS_MACRO uint64_t & asuint64_t()
    {
    	return *reinterpret_cast<uint64_t*>(this);
    }
    AS_MACRO const uint64_t & asuint64_t()const
    {
    	return *reinterpret_cast<const uint64_t*>(this);
    }
    AS_MACRO static RegID_AA64MMFR0_EL1 make(uint64_t val)
    {
        RegID_AA64MMFR0_EL1 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    AS_MACRO static RegID_AA64MMFR0_EL1 read()
    { 
        RegID_AA64MMFR0_EL1 res;
        __asm__ __volatile__("mrs %0,ID_AA64MMFR0_EL1\n\t":"=r"(res));
        return res;
    }
    AS_MACRO RegID_AA64MMFR0_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,ID_AA64MMFR0_EL1\n\t":"=r"(*this));
        return *this;
    }
    AS_MACRO void write()const
    {
        __asm__ __volatile__("msr ID_AA64MMFR0_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegMIDR_EL1 
{
public:
    using ScaleType=uint32_t;
            uint32_t  Revision:4;
            uint32_t  PartNum:12;
            uint32_t  Architecture:4;
            uint32_t  Variant:4;
            uint32_t  Implementer:8;
    AS_MACRO uint32_t  get()const 
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    AS_MACRO uint32_t  get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }
    
    AS_MACRO RegMIDR_EL1& set(uint32_t v)
    { 
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    AS_MACRO volatile RegMIDR_EL1 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    AS_MACRO RegMIDR_EL1 & setMandatoryFields()
    {
        Revision = 0;
        PartNum = 0;
        Architecture = 0;
        Variant = 0;
        Implementer = 0;
        return *this;
        }
    AS_MACRO RegMIDR_EL1 copy()const volatile
    {
    	RegMIDR_EL1 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO RegMIDR_EL1 copy()const
    {
    	RegMIDR_EL1 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO void dump()const volatile
    {
        kout << "RegMIDR_EL1: ";
            kout
                << "Revision = " << Revision << ", "
                << "PartNum = " << PartNum << ", "
                << "Architecture = " << Architecture << ", "
                << "Variant = " << Variant << ", "
                << "Implementer = " << Implementer << ", "
                << "\n";
    }
    AS_MACRO void dump()const
    {
    	reinterpret_cast<volatile const RegMIDR_EL1*>(this)->dump();
    }
    AS_MACRO uint32_t & asuint32_t()
    {
    	return *reinterpret_cast<uint32_t*>(this);
    }
    AS_MACRO const uint32_t & asuint32_t()const
    {
    	return *reinterpret_cast<const uint32_t*>(this);
    }
    AS_MACRO static RegMIDR_EL1 make(uint32_t val)
    {
        RegMIDR_EL1 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    AS_MACRO static RegMIDR_EL1 read()
    { 
        RegMIDR_EL1 res;
        __asm__ __volatile__("mrs %0,MIDR_EL1\n\t":"=r"(res));
        return res;
    }
    AS_MACRO RegMIDR_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,MIDR_EL1\n\t":"=r"(*this));
        return *this;
    }
    AS_MACRO void write()const
    {
        __asm__ __volatile__("msr MIDR_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegMPIDR_EL1 
{
public:
    using ScaleType=uint64_t;
            uint64_t  Aff0:8;
            uint64_t  Aff1:8;
            uint64_t  Aff2:8;
            uint64_t  MT:1;
            uint64_t  RES0_0:5;
            uint64_t  U:1;
            uint64_t  RES1_1:1;
            uint64_t  Aff3:8;
            uint64_t  RES0_2:24;
    AS_MACRO uint64_t  get()const 
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    AS_MACRO uint64_t  get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }
    
    AS_MACRO RegMPIDR_EL1& set(uint64_t v)
    { 
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    AS_MACRO volatile RegMPIDR_EL1 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    AS_MACRO RegMPIDR_EL1 & setMandatoryFields()
    {
        Aff0 = 0;
        Aff1 = 0;
        Aff2 = 0;
        MT = 0;
        RES0_0 = 0;
        U = 0;
        RES1_1 = 1;
        Aff3 = 0;
        RES0_2 = 0;
        return *this;
        }
    AS_MACRO RegMPIDR_EL1 copy()const volatile
    {
    	RegMPIDR_EL1 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO RegMPIDR_EL1 copy()const
    {
    	RegMPIDR_EL1 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO void dump()const volatile
    {
        kout << "RegMPIDR_EL1: ";
            kout
                << "Aff0 = " << Aff0 << ", "
                << "Aff1 = " << Aff1 << ", "
                << "Aff2 = " << Aff2 << ", "
                << "MT = " << MT << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "U = " << U << ", "
                << "RES1_1 = " << RES1_1 << ", "
                << "Aff3 = " << Aff3 << ", "
                << "RES0_2 = " << RES0_2 << ", "
                << "\n";
    }
    AS_MACRO void dump()const
    {
    	reinterpret_cast<volatile const RegMPIDR_EL1*>(this)->dump();
    }
    AS_MACRO uint64_t & asuint64_t()
    {
    	return *reinterpret_cast<uint64_t*>(this);
    }
    AS_MACRO const uint64_t & asuint64_t()const
    {
    	return *reinterpret_cast<const uint64_t*>(this);
    }
    AS_MACRO static RegMPIDR_EL1 make(uint64_t val)
    {
        RegMPIDR_EL1 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    AS_MACRO static RegMPIDR_EL1 read()
    { 
        RegMPIDR_EL1 res;
        __asm__ __volatile__("mrs %0,MPIDR_EL1\n\t":"=r"(res));
        return res;
    }
    AS_MACRO RegMPIDR_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,MPIDR_EL1\n\t":"=r"(*this));
        return *this;
    }
    AS_MACRO void write()const
    {
        __asm__ __volatile__("msr MPIDR_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegTTBR0_EL1 
{
public:
    using ScaleType=uint64_t;
            uint64_t  CnP:1;
            uint64_t  BADDR:47;
            uint64_t  ASID:16;
    AS_MACRO uint64_t  get()const 
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    AS_MACRO uint64_t  get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }
    
    AS_MACRO RegTTBR0_EL1& set(uint64_t v)
    { 
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    AS_MACRO volatile RegTTBR0_EL1 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    AS_MACRO RegTTBR0_EL1 & setMandatoryFields()
    {
        CnP = 0;
        BADDR = 0;
        ASID = 0;
        return *this;
        }
    AS_MACRO RegTTBR0_EL1 copy()const volatile
    {
    	RegTTBR0_EL1 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO RegTTBR0_EL1 copy()const
    {
    	RegTTBR0_EL1 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO void dump()const volatile
    {
        kout << "RegTTBR0_EL1: ";
            kout
                << "CnP = " << CnP << ", "
                << "BADDR = " << Hex(BADDR) << ", "
                << "ASID = " << ASID << ", "
                << "\n";
    }
    AS_MACRO void dump()const
    {
    	reinterpret_cast<volatile const RegTTBR0_EL1*>(this)->dump();
    }
    AS_MACRO uint64_t & asuint64_t()
    {
    	return *reinterpret_cast<uint64_t*>(this);
    }
    AS_MACRO const uint64_t & asuint64_t()const
    {
    	return *reinterpret_cast<const uint64_t*>(this);
    }
    AS_MACRO static RegTTBR0_EL1 make(uint64_t val)
    {
        RegTTBR0_EL1 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    AS_MACRO static RegTTBR0_EL1 read()
    { 
        RegTTBR0_EL1 res;
        __asm__ __volatile__("mrs %0,TTBR0_EL1\n\t":"=r"(res));
        return res;
    }
    AS_MACRO RegTTBR0_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,TTBR0_EL1\n\t":"=r"(*this));
        return *this;
    }
    AS_MACRO void write()const
    {
        __asm__ __volatile__("msr TTBR0_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegTTBR1_EL1 
{
public:
    using ScaleType=uint64_t;
            uint64_t  CnP:1;
            uint64_t  BADDR:47;
            uint64_t  ASID:16;
    AS_MACRO uint64_t  get()const 
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    AS_MACRO uint64_t  get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }
    
    AS_MACRO RegTTBR1_EL1& set(uint64_t v)
    { 
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    AS_MACRO volatile RegTTBR1_EL1 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    AS_MACRO RegTTBR1_EL1 & setMandatoryFields()
    {
        CnP = 0;
        BADDR = 0;
        ASID = 0;
        return *this;
        }
    AS_MACRO RegTTBR1_EL1 copy()const volatile
    {
    	RegTTBR1_EL1 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO RegTTBR1_EL1 copy()const
    {
    	RegTTBR1_EL1 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO void dump()const volatile
    {
        kout << "RegTTBR1_EL1: ";
            kout
                << "CnP = " << CnP << ", "
                << "BADDR = " << Hex(BADDR) << ", "
                << "ASID = " << ASID << ", "
                << "\n";
    }
    AS_MACRO void dump()const
    {
    	reinterpret_cast<volatile const RegTTBR1_EL1*>(this)->dump();
    }
    AS_MACRO uint64_t & asuint64_t()
    {
    	return *reinterpret_cast<uint64_t*>(this);
    }
    AS_MACRO const uint64_t & asuint64_t()const
    {
    	return *reinterpret_cast<const uint64_t*>(this);
    }
    AS_MACRO static RegTTBR1_EL1 make(uint64_t val)
    {
        RegTTBR1_EL1 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    AS_MACRO static RegTTBR1_EL1 read()
    { 
        RegTTBR1_EL1 res;
        __asm__ __volatile__("mrs %0,TTBR1_EL1\n\t":"=r"(res));
        return res;
    }
    AS_MACRO RegTTBR1_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,TTBR1_EL1\n\t":"=r"(*this));
        return *this;
    }
    AS_MACRO void write()const
    {
        __asm__ __volatile__("msr TTBR1_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegPAR_EL1 
{
public:
    using ScaleType=uint64_t;
    union {
        struct {
            uint64_t  F:1;
            uint64_t  RES0_0:6;
            uint64_t  SH:2;
            uint64_t  NS:1;
            uint64_t  IMP_DEF_1:1;
            uint64_t  RES1_2:1;
            uint64_t  PA47_12:36;
            uint64_t  PA51_48:4;
            uint64_t  RES0_3:4;
            uint64_t  ATTR:8;
        }__attribute__((packed)) S0;
        struct {
            uint64_t  F:1;
            uint64_t  FST:6;
            uint64_t  RES0_0:1;
            uint64_t  PTW:1;
            uint64_t  S:1;
            uint64_t  RES0_1:1;
            uint64_t  RES1_2:1;
            uint64_t  RES0_3:36;
            uint64_t  IMP_DEF0:4;
            uint64_t  IMP_DEF1:4;
            uint64_t  IMP_DEF2:8;
        }__attribute__((packed)) S1;
    }; //union
    AS_MACRO uint64_t  get()const 
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    AS_MACRO uint64_t  get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }
    
    AS_MACRO RegPAR_EL1& set(uint64_t v)
    { 
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    AS_MACRO volatile RegPAR_EL1 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    AS_MACRO RegPAR_EL1 copy()const volatile
    {
    	RegPAR_EL1 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO RegPAR_EL1 copy()const
    {
    	RegPAR_EL1 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO void dump()const volatile
    {
        kout << "RegPAR_EL1: ";
        if(S0.F==0)
        {
            kout
                << "S0.F = " << S0.F << ", "
                << "S0.RES0_0 = " << S0.RES0_0 << ", "
                << "S0.SH = " << S0.SH << ", "
                << "S0.NS = " << S0.NS << ", "
                << "S0.IMP_DEF_1 = " << S0.IMP_DEF_1 << ", "
                << "S0.RES1_2 = " << S0.RES1_2 << ", "
                << "S0.PA47_12 = " << Hex(S0.PA47_12) << ", "
                << "S0.PA51_48 = " << Hex(S0.PA51_48) << ", "
                << "S0.RES0_3 = " << S0.RES0_3 << ", "
                << "S0.ATTR = " << S0.ATTR << ", "
                << "\n";
        }
        else
        {
            kout
                << "S1.F = " << S1.F << ", "
                << "S1.FST = " << S1.FST << ", "
                << "S1.RES0_0 = " << S1.RES0_0 << ", "
                << "S1.PTW = " << S1.PTW << ", "
                << "S1.S = " << S1.S << ", "
                << "S1.RES0_1 = " << S1.RES0_1 << ", "
                << "S1.RES1_2 = " << S1.RES1_2 << ", "
                << "S1.RES0_3 = " << S1.RES0_3 << ", "
                << "S1.IMP_DEF0 = " << S1.IMP_DEF0 << ", "
                << "S1.IMP_DEF1 = " << S1.IMP_DEF1 << ", "
                << "S1.IMP_DEF2 = " << S1.IMP_DEF2 << ", "
                << "\n";
        }
    }
    AS_MACRO void dump()const
    {
    	reinterpret_cast<volatile const RegPAR_EL1*>(this)->dump();
    }
    AS_MACRO uint64_t & asuint64_t()
    {
    	return *reinterpret_cast<uint64_t*>(this);
    }
    AS_MACRO const uint64_t & asuint64_t()const
    {
    	return *reinterpret_cast<const uint64_t*>(this);
    }
    AS_MACRO static RegPAR_EL1 make(uint64_t val)
    {
        RegPAR_EL1 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    AS_MACRO static RegPAR_EL1 read()
    { 
        RegPAR_EL1 res;
        __asm__ __volatile__("mrs %0,PAR_EL1\n\t":"=r"(res));
        return res;
    }
    AS_MACRO RegPAR_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,PAR_EL1\n\t":"=r"(*this));
        return *this;
    }
    AS_MACRO void write()const
    {
        __asm__ __volatile__("msr PAR_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegMAIR_EL1 
{
public:
    using ScaleType=uint64_t;
            uint64_t  Attr0:8;
            uint64_t  Attr1:8;
            uint64_t  Attr2:8;
            uint64_t  Attr3:8;
            uint64_t  Attr4:8;
            uint64_t  Attr5:8;
            uint64_t  Attr6:8;
            uint64_t  Attr7:8;
    AS_MACRO uint64_t  get()const 
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    AS_MACRO uint64_t  get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }
    
    AS_MACRO RegMAIR_EL1& set(uint64_t v)
    { 
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    AS_MACRO volatile RegMAIR_EL1 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    AS_MACRO RegMAIR_EL1 & setMandatoryFields()
    {
        Attr0 = 0;
        Attr1 = 0;
        Attr2 = 0;
        Attr3 = 0;
        Attr4 = 0;
        Attr5 = 0;
        Attr6 = 0;
        Attr7 = 0;
        return *this;
        }
    AS_MACRO RegMAIR_EL1 copy()const volatile
    {
    	RegMAIR_EL1 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO RegMAIR_EL1 copy()const
    {
    	RegMAIR_EL1 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO void dump()const volatile
    {
        kout << "RegMAIR_EL1: ";
            kout
                << "Attr0 = " << Hex(Attr0) << ", "
                << "Attr1 = " << Hex(Attr1) << ", "
                << "Attr2 = " << Hex(Attr2) << ", "
                << "Attr3 = " << Hex(Attr3) << ", "
                << "Attr4 = " << Hex(Attr4) << ", "
                << "Attr5 = " << Hex(Attr5) << ", "
                << "Attr6 = " << Hex(Attr6) << ", "
                << "Attr7 = " << Hex(Attr7) << ", "
                << "\n";
    }
    AS_MACRO void dump()const
    {
    	reinterpret_cast<volatile const RegMAIR_EL1*>(this)->dump();
    }
    AS_MACRO uint64_t & asuint64_t()
    {
    	return *reinterpret_cast<uint64_t*>(this);
    }
    AS_MACRO const uint64_t & asuint64_t()const
    {
    	return *reinterpret_cast<const uint64_t*>(this);
    }
    AS_MACRO static RegMAIR_EL1 make(uint64_t val)
    {
        RegMAIR_EL1 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    AS_MACRO static RegMAIR_EL1 read()
    { 
        RegMAIR_EL1 res;
        __asm__ __volatile__("mrs %0,MAIR_EL1\n\t":"=r"(res));
        return res;
    }
    AS_MACRO RegMAIR_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,MAIR_EL1\n\t":"=r"(*this));
        return *this;
    }
    AS_MACRO void write()const
    {
        __asm__ __volatile__("msr MAIR_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegMAIR_EL2 
{
public:
    using ScaleType=uint64_t;
            uint64_t  Attr0:8;
            uint64_t  Attr1:8;
            uint64_t  Attr2:8;
            uint64_t  Attr3:8;
            uint64_t  Attr4:8;
            uint64_t  Attr5:8;
            uint64_t  Attr6:8;
            uint64_t  Attr7:8;
    AS_MACRO uint64_t  get()const 
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    AS_MACRO uint64_t  get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }
    
    AS_MACRO RegMAIR_EL2& set(uint64_t v)
    { 
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    AS_MACRO volatile RegMAIR_EL2 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    AS_MACRO RegMAIR_EL2 & setMandatoryFields()
    {
        Attr0 = 0;
        Attr1 = 0;
        Attr2 = 0;
        Attr3 = 0;
        Attr4 = 0;
        Attr5 = 0;
        Attr6 = 0;
        Attr7 = 0;
        return *this;
        }
    AS_MACRO RegMAIR_EL2 copy()const volatile
    {
    	RegMAIR_EL2 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO RegMAIR_EL2 copy()const
    {
    	RegMAIR_EL2 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO void dump()const volatile
    {
        kout << "RegMAIR_EL2: ";
            kout
                << "Attr0 = " << Hex(Attr0) << ", "
                << "Attr1 = " << Hex(Attr1) << ", "
                << "Attr2 = " << Hex(Attr2) << ", "
                << "Attr3 = " << Hex(Attr3) << ", "
                << "Attr4 = " << Hex(Attr4) << ", "
                << "Attr5 = " << Hex(Attr5) << ", "
                << "Attr6 = " << Hex(Attr6) << ", "
                << "Attr7 = " << Hex(Attr7) << ", "
                << "\n";
    }
    AS_MACRO void dump()const
    {
    	reinterpret_cast<volatile const RegMAIR_EL2*>(this)->dump();
    }
    AS_MACRO uint64_t & asuint64_t()
    {
    	return *reinterpret_cast<uint64_t*>(this);
    }
    AS_MACRO const uint64_t & asuint64_t()const
    {
    	return *reinterpret_cast<const uint64_t*>(this);
    }
    AS_MACRO static RegMAIR_EL2 make(uint64_t val)
    {
        RegMAIR_EL2 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    AS_MACRO static RegMAIR_EL2 read()
    { 
        RegMAIR_EL2 res;
        __asm__ __volatile__("mrs %0,MAIR_EL2\n\t":"=r"(res));
        return res;
    }
    AS_MACRO RegMAIR_EL2 & update()
    {
        __asm__ __volatile__("mrs %0,MAIR_EL2\n\t":"=r"(*this));
        return *this;
    }
    AS_MACRO void write()const
    {
        __asm__ __volatile__("msr MAIR_EL2,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegMAIR_EL3 
{
public:
    using ScaleType=uint64_t;
            uint64_t  Attr0:8;
            uint64_t  Attr1:8;
            uint64_t  Attr2:8;
            uint64_t  Attr3:8;
            uint64_t  Attr4:8;
            uint64_t  Attr5:8;
            uint64_t  Attr6:8;
            uint64_t  Attr7:8;
    AS_MACRO uint64_t  get()const 
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    AS_MACRO uint64_t  get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }
    
    AS_MACRO RegMAIR_EL3& set(uint64_t v)
    { 
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    AS_MACRO volatile RegMAIR_EL3 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    AS_MACRO RegMAIR_EL3 & setMandatoryFields()
    {
        Attr0 = 0;
        Attr1 = 0;
        Attr2 = 0;
        Attr3 = 0;
        Attr4 = 0;
        Attr5 = 0;
        Attr6 = 0;
        Attr7 = 0;
        return *this;
        }
    AS_MACRO RegMAIR_EL3 copy()const volatile
    {
    	RegMAIR_EL3 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO RegMAIR_EL3 copy()const
    {
    	RegMAIR_EL3 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO void dump()const volatile
    {
        kout << "RegMAIR_EL3: ";
            kout
                << "Attr0 = " << Hex(Attr0) << ", "
                << "Attr1 = " << Hex(Attr1) << ", "
                << "Attr2 = " << Hex(Attr2) << ", "
                << "Attr3 = " << Hex(Attr3) << ", "
                << "Attr4 = " << Hex(Attr4) << ", "
                << "Attr5 = " << Hex(Attr5) << ", "
                << "Attr6 = " << Hex(Attr6) << ", "
                << "Attr7 = " << Hex(Attr7) << ", "
                << "\n";
    }
    AS_MACRO void dump()const
    {
    	reinterpret_cast<volatile const RegMAIR_EL3*>(this)->dump();
    }
    AS_MACRO uint64_t & asuint64_t()
    {
    	return *reinterpret_cast<uint64_t*>(this);
    }
    AS_MACRO const uint64_t & asuint64_t()const
    {
    	return *reinterpret_cast<const uint64_t*>(this);
    }
    AS_MACRO static RegMAIR_EL3 make(uint64_t val)
    {
        RegMAIR_EL3 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    AS_MACRO static RegMAIR_EL3 read()
    { 
        RegMAIR_EL3 res;
        __asm__ __volatile__("mrs %0,MAIR_EL3\n\t":"=r"(res));
        return res;
    }
    AS_MACRO RegMAIR_EL3 & update()
    {
        __asm__ __volatile__("mrs %0,MAIR_EL3\n\t":"=r"(*this));
        return *this;
    }
    AS_MACRO void write()const
    {
        __asm__ __volatile__("msr MAIR_EL3,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegSCTLR_EL1 
{
public:
    using ScaleType=uint32_t;
            uint32_t  M:1;
            uint32_t  A:1;
            uint32_t  C:1;
            uint32_t  SA:1;
            uint32_t  SA0:1;
            uint32_t  CP15BEN:1;
            uint32_t  RES0_0:1;
            uint32_t  ITD:1;
            uint32_t  SED:1;
            uint32_t  UMA:1;
            uint32_t  RES0_1:1;
            uint32_t  RES1_2:1;
            uint32_t  I:1;
            uint32_t  RES0_3:1;
            uint32_t  DZE:1;
            uint32_t  UCT:1;
            uint32_t  nTWI:1;
            uint32_t  RES0_4:1;
            uint32_t  nTWE:1;
            uint32_t  WXN:1;
            uint32_t  RES1_5:1;
            uint32_t  IESB:1;
            uint32_t  RES1_6:1;
            uint32_t  SPAN:1;
            uint32_t  E0E:1;
            uint32_t  EE:1;
            uint32_t  UCI:1;
            uint32_t  RES0_7:1;
            uint32_t  nTLSMD:1;
            uint32_t  LSMAOE:1;
            uint32_t  RES0_8:2;
    AS_MACRO uint32_t  get()const 
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    AS_MACRO uint32_t  get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }
    
    AS_MACRO RegSCTLR_EL1& set(uint32_t v)
    { 
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    AS_MACRO volatile RegSCTLR_EL1 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    AS_MACRO RegSCTLR_EL1 & setMandatoryFields()
    {
        M = 0;
        A = 0;
        C = 0;
        SA = 0;
        SA0 = 0;
        CP15BEN = 0;
        RES0_0 = 0;
        ITD = 0;
        SED = 0;
        UMA = 0;
        RES0_1 = 0;
        RES1_2 = 1;
        I = 0;
        RES0_3 = 0;
        DZE = 0;
        UCT = 0;
        nTWI = 0;
        RES0_4 = 0;
        nTWE = 0;
        WXN = 0;
        RES1_5 = 1;
        IESB = 0;
        RES1_6 = 1;
        SPAN = 0;
        E0E = 0;
        EE = 0;
        UCI = 0;
        RES0_7 = 0;
        nTLSMD = 0;
        LSMAOE = 0;
        RES0_8 = 0;
        return *this;
        }
    AS_MACRO RegSCTLR_EL1 copy()const volatile
    {
    	RegSCTLR_EL1 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO RegSCTLR_EL1 copy()const
    {
    	RegSCTLR_EL1 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO void dump()const volatile
    {
        kout << "RegSCTLR_EL1: ";
            kout
                << "M = " << M << ", "
                << "A = " << A << ", "
                << "C = " << C << ", "
                << "SA = " << SA << ", "
                << "SA0 = " << SA0 << ", "
                << "CP15BEN = " << CP15BEN << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "ITD = " << ITD << ", "
                << "SED = " << SED << ", "
                << "UMA = " << UMA << ", "
                << "RES0_1 = " << RES0_1 << ", "
                << "RES1_2 = " << RES1_2 << ", "
                << "I = " << I << ", "
                << "RES0_3 = " << RES0_3 << ", "
                << "DZE = " << DZE << ", "
                << "UCT = " << UCT << ", "
                << "nTWI = " << nTWI << ", "
                << "RES0_4 = " << RES0_4 << ", "
                << "nTWE = " << nTWE << ", "
                << "WXN = " << WXN << ", "
                << "RES1_5 = " << RES1_5 << ", "
                << "IESB = " << IESB << ", "
                << "RES1_6 = " << RES1_6 << ", "
                << "SPAN = " << SPAN << ", "
                << "E0E = " << E0E << ", "
                << "EE = " << EE << ", "
                << "UCI = " << UCI << ", "
                << "RES0_7 = " << RES0_7 << ", "
                << "nTLSMD = " << nTLSMD << ", "
                << "LSMAOE = " << LSMAOE << ", "
                << "RES0_8 = " << RES0_8 << ", "
                << "\n";
    }
    AS_MACRO void dump()const
    {
    	reinterpret_cast<volatile const RegSCTLR_EL1*>(this)->dump();
    }
    AS_MACRO uint32_t & asuint32_t()
    {
    	return *reinterpret_cast<uint32_t*>(this);
    }
    AS_MACRO const uint32_t & asuint32_t()const
    {
    	return *reinterpret_cast<const uint32_t*>(this);
    }
    AS_MACRO static RegSCTLR_EL1 make(uint32_t val)
    {
        RegSCTLR_EL1 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    AS_MACRO static RegSCTLR_EL1 read()
    { 
        RegSCTLR_EL1 res;
        __asm__ __volatile__("mrs %0,SCTLR_EL1\n\t":"=r"(res));
        return res;
    }
    AS_MACRO RegSCTLR_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,SCTLR_EL1\n\t":"=r"(*this));
        return *this;
    }
    AS_MACRO void write()const
    {
        __asm__ __volatile__("msr SCTLR_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegDLR_EL0 
{
public:
    using ScaleType=uint64_t;
            uint64_t  RestartAddr:64;
    AS_MACRO uint64_t  get()const 
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    AS_MACRO uint64_t  get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }
    
    AS_MACRO RegDLR_EL0& set(uint64_t v)
    { 
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    AS_MACRO volatile RegDLR_EL0 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    AS_MACRO RegDLR_EL0 & setMandatoryFields()
    {
        RestartAddr = 0;
        return *this;
        }
    AS_MACRO RegDLR_EL0 copy()const volatile
    {
    	RegDLR_EL0 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO RegDLR_EL0 copy()const
    {
    	RegDLR_EL0 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO void dump()const volatile
    {
        kout << "RegDLR_EL0: ";
            kout
                << "RestartAddr = " << RestartAddr << ", "
                << "\n";
    }
    AS_MACRO void dump()const
    {
    	reinterpret_cast<volatile const RegDLR_EL0*>(this)->dump();
    }
    AS_MACRO uint64_t & asuint64_t()
    {
    	return *reinterpret_cast<uint64_t*>(this);
    }
    AS_MACRO const uint64_t & asuint64_t()const
    {
    	return *reinterpret_cast<const uint64_t*>(this);
    }
    AS_MACRO static RegDLR_EL0 make(uint64_t val)
    {
        RegDLR_EL0 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    AS_MACRO static RegDLR_EL0 read()
    { 
        RegDLR_EL0 res;
        __asm__ __volatile__("mrs %0,DLR_EL0\n\t":"=r"(res));
        return res;
    }
    AS_MACRO RegDLR_EL0 & update()
    {
        __asm__ __volatile__("mrs %0,DLR_EL0\n\t":"=r"(*this));
        return *this;
    }
    AS_MACRO void write()const
    {
        __asm__ __volatile__("msr DLR_EL0,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegDSPSR_EL0 
{
public:
    using ScaleType=uint32_t;
            uint32_t  SPSel:1;
            uint32_t  RES0_0:1;
            uint32_t  EL:2;
            uint32_t  ExeState:1;
            uint32_t  RES0_1:1;
            uint32_t  FIQMask:1;
            uint32_t  IRQMask:1;
            uint32_t  SErrorMask:1;
            uint32_t  DebugMask:1;
            uint32_t  RES0_2:10;
            uint32_t  IL:1;
            uint32_t  SoftwareStep:1;
            uint32_t  PAN:1;
            uint32_t  UAO:1;
            uint32_t  RES0_3:4;
            uint32_t  V:1;
            uint32_t  C:1;
            uint32_t  Z:1;
            uint32_t  N:1;
    AS_MACRO uint32_t  get()const 
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    AS_MACRO uint32_t  get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }
    
    AS_MACRO RegDSPSR_EL0& set(uint32_t v)
    { 
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    AS_MACRO volatile RegDSPSR_EL0 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    AS_MACRO RegDSPSR_EL0 & setMandatoryFields()
    {
        SPSel = 0;
        RES0_0 = 0;
        EL = 0;
        ExeState = 0;
        RES0_1 = 0;
        FIQMask = 0;
        IRQMask = 0;
        SErrorMask = 0;
        DebugMask = 0;
        RES0_2 = 0;
        IL = 0;
        SoftwareStep = 0;
        PAN = 0;
        UAO = 0;
        RES0_3 = 0;
        V = 0;
        C = 0;
        Z = 0;
        N = 0;
        return *this;
        }
    AS_MACRO RegDSPSR_EL0 copy()const volatile
    {
    	RegDSPSR_EL0 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO RegDSPSR_EL0 copy()const
    {
    	RegDSPSR_EL0 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO void dump()const volatile
    {
        kout << "RegDSPSR_EL0: ";
            kout
                << "SPSel = " << SPSel << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "EL = " << EL << ", "
                << "ExeState = " << ExeState << ", "
                << "RES0_1 = " << RES0_1 << ", "
                << "FIQMask = " << FIQMask << ", "
                << "IRQMask = " << IRQMask << ", "
                << "SErrorMask = " << SErrorMask << ", "
                << "DebugMask = " << DebugMask << ", "
                << "RES0_2 = " << RES0_2 << ", "
                << "IL = " << IL << ", "
                << "SoftwareStep = " << SoftwareStep << ", "
                << "PAN = " << PAN << ", "
                << "UAO = " << UAO << ", "
                << "RES0_3 = " << RES0_3 << ", "
                << "V = " << V << ", "
                << "C = " << C << ", "
                << "Z = " << Z << ", "
                << "N = " << N << ", "
                << "\n";
    }
    AS_MACRO void dump()const
    {
    	reinterpret_cast<volatile const RegDSPSR_EL0*>(this)->dump();
    }
    AS_MACRO uint32_t & asuint32_t()
    {
    	return *reinterpret_cast<uint32_t*>(this);
    }
    AS_MACRO const uint32_t & asuint32_t()const
    {
    	return *reinterpret_cast<const uint32_t*>(this);
    }
    AS_MACRO static RegDSPSR_EL0 make(uint32_t val)
    {
        RegDSPSR_EL0 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    AS_MACRO static RegDSPSR_EL0 read()
    { 
        RegDSPSR_EL0 res;
        __asm__ __volatile__("mrs %0,DSPSR_EL0\n\t":"=r"(res));
        return res;
    }
    AS_MACRO RegDSPSR_EL0 & update()
    {
        __asm__ __volatile__("mrs %0,DSPSR_EL0\n\t":"=r"(*this));
        return *this;
    }
    AS_MACRO void write()const
    {
        __asm__ __volatile__("msr DSPSR_EL0,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegHCR_EL2 
{
public:
    using ScaleType=uint64_t;
            uint64_t  VM:1;
            uint64_t  SWIO:1;
            uint64_t  PTW:1;
            uint64_t  FMO:1;
            uint64_t  IMO:1;
            uint64_t  AMO:1;
            uint64_t  VF:1;
            uint64_t  VI:1;
            uint64_t  VSE:1;
            uint64_t  FB:1;
            uint64_t  BSU:2;
            uint64_t  DC:1;
            uint64_t  TWI:1;
            uint64_t  TWE:1;
            uint64_t  TID0:1;
            uint64_t  TID1:1;
            uint64_t  TID2:1;
            uint64_t  TID3:1;
            uint64_t  TSC:1;
            uint64_t  TIDCP:1;
            uint64_t  TACR:1;
            uint64_t  TSW:1;
            uint64_t  TPCP:1;
            uint64_t  TPU:1;
            uint64_t  TTLB:1;
            uint64_t  TVM:1;
            uint64_t  TGE:1;
            uint64_t  TDZ:1;
            uint64_t  HCD:1;
            uint64_t  TRVM:1;
            uint64_t  RW:1;
            uint64_t  CD:1;
            uint64_t  ID:1;
            uint64_t  E2H:1;
            uint64_t  TLOR:1;
            uint64_t  TERR:1;
            uint64_t  TEA:1;
            uint64_t  MIOCNCE:1;
            uint64_t  RES0_0:25;
    AS_MACRO uint64_t  get()const 
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    AS_MACRO uint64_t  get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }
    
    AS_MACRO RegHCR_EL2& set(uint64_t v)
    { 
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    AS_MACRO volatile RegHCR_EL2 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    AS_MACRO RegHCR_EL2 & setMandatoryFields()
    {
        VM = 0;
        SWIO = 0;
        PTW = 0;
        FMO = 0;
        IMO = 0;
        AMO = 0;
        VF = 0;
        VI = 0;
        VSE = 0;
        FB = 0;
        BSU = 0;
        DC = 0;
        TWI = 0;
        TWE = 0;
        TID0 = 0;
        TID1 = 0;
        TID2 = 0;
        TID3 = 0;
        TSC = 0;
        TIDCP = 0;
        TACR = 0;
        TSW = 0;
        TPCP = 0;
        TPU = 0;
        TTLB = 0;
        TVM = 0;
        TGE = 0;
        TDZ = 0;
        HCD = 0;
        TRVM = 0;
        RW = 0;
        CD = 0;
        ID = 0;
        E2H = 0;
        TLOR = 0;
        TERR = 0;
        TEA = 0;
        MIOCNCE = 0;
        RES0_0 = 0;
        return *this;
        }
    AS_MACRO RegHCR_EL2 copy()const volatile
    {
    	RegHCR_EL2 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO RegHCR_EL2 copy()const
    {
    	RegHCR_EL2 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO void dump()const volatile
    {
        kout << "RegHCR_EL2: ";
            kout
                << "VM = " << VM << ", "
                << "SWIO = " << SWIO << ", "
                << "PTW = " << PTW << ", "
                << "FMO = " << FMO << ", "
                << "IMO = " << IMO << ", "
                << "AMO = " << AMO << ", "
                << "VF = " << VF << ", "
                << "VI = " << VI << ", "
                << "VSE = " << VSE << ", "
                << "FB = " << FB << ", "
                << "BSU = " << BSU << ", "
                << "DC = " << DC << ", "
                << "TWI = " << TWI << ", "
                << "TWE = " << TWE << ", "
                << "TID0 = " << TID0 << ", "
                << "TID1 = " << TID1 << ", "
                << "TID2 = " << TID2 << ", "
                << "TID3 = " << TID3 << ", "
                << "TSC = " << TSC << ", "
                << "TIDCP = " << TIDCP << ", "
                << "TACR = " << TACR << ", "
                << "TSW = " << TSW << ", "
                << "TPCP = " << TPCP << ", "
                << "TPU = " << TPU << ", "
                << "TTLB = " << TTLB << ", "
                << "TVM = " << TVM << ", "
                << "TGE = " << TGE << ", "
                << "TDZ = " << TDZ << ", "
                << "HCD = " << HCD << ", "
                << "TRVM = " << TRVM << ", "
                << "RW = " << RW << ", "
                << "CD = " << CD << ", "
                << "ID = " << ID << ", "
                << "E2H = " << E2H << ", "
                << "TLOR = " << TLOR << ", "
                << "TERR = " << TERR << ", "
                << "TEA = " << TEA << ", "
                << "MIOCNCE = " << MIOCNCE << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "\n";
    }
    AS_MACRO void dump()const
    {
    	reinterpret_cast<volatile const RegHCR_EL2*>(this)->dump();
    }
    AS_MACRO uint64_t & asuint64_t()
    {
    	return *reinterpret_cast<uint64_t*>(this);
    }
    AS_MACRO const uint64_t & asuint64_t()const
    {
    	return *reinterpret_cast<const uint64_t*>(this);
    }
    AS_MACRO static RegHCR_EL2 make(uint64_t val)
    {
        RegHCR_EL2 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    AS_MACRO static RegHCR_EL2 read()
    { 
        RegHCR_EL2 res;
        __asm__ __volatile__("mrs %0,HCR_EL2\n\t":"=r"(res));
        return res;
    }
    AS_MACRO RegHCR_EL2 & update()
    {
        __asm__ __volatile__("mrs %0,HCR_EL2\n\t":"=r"(*this));
        return *this;
    }
    AS_MACRO void write()const
    {
        __asm__ __volatile__("msr HCR_EL2,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegSCR_EL3 
{
public:
    using ScaleType=uint32_t;
            uint32_t  NS:1;
            uint32_t  FIQ:1;
            uint32_t  IRQ:1;
            uint32_t  EA:1;
            uint32_t  RES1_0:2;
            uint32_t  RES0_1:1;
            uint32_t  SMD:1;
            uint32_t  HCE:1;
            uint32_t  SIF:1;
            uint32_t  RW:1;
            uint32_t  ST:1;
            uint32_t  TWI:1;
            uint32_t  TWE:1;
            uint32_t  TLOR:1;
            uint32_t  TERR:1;
            uint32_t  RES0_2:16;
    AS_MACRO uint32_t  get()const 
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    AS_MACRO uint32_t  get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }
    
    AS_MACRO RegSCR_EL3& set(uint32_t v)
    { 
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    AS_MACRO volatile RegSCR_EL3 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    AS_MACRO RegSCR_EL3 & setMandatoryFields()
    {
        NS = 0;
        FIQ = 0;
        IRQ = 0;
        EA = 0;
        RES1_0 = 1;
        RES0_1 = 0;
        SMD = 0;
        HCE = 0;
        SIF = 0;
        RW = 0;
        ST = 0;
        TWI = 0;
        TWE = 0;
        TLOR = 0;
        TERR = 0;
        RES0_2 = 0;
        return *this;
        }
    AS_MACRO RegSCR_EL3 copy()const volatile
    {
    	RegSCR_EL3 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO RegSCR_EL3 copy()const
    {
    	RegSCR_EL3 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO void dump()const volatile
    {
        kout << "RegSCR_EL3: ";
            kout
                << "NS = " << NS << ", "
                << "FIQ = " << FIQ << ", "
                << "IRQ = " << IRQ << ", "
                << "EA = " << EA << ", "
                << "RES1_0 = " << RES1_0 << ", "
                << "RES0_1 = " << RES0_1 << ", "
                << "SMD = " << SMD << ", "
                << "HCE = " << HCE << ", "
                << "SIF = " << SIF << ", "
                << "RW = " << RW << ", "
                << "ST = " << ST << ", "
                << "TWI = " << TWI << ", "
                << "TWE = " << TWE << ", "
                << "TLOR = " << TLOR << ", "
                << "TERR = " << TERR << ", "
                << "RES0_2 = " << RES0_2 << ", "
                << "\n";
    }
    AS_MACRO void dump()const
    {
    	reinterpret_cast<volatile const RegSCR_EL3*>(this)->dump();
    }
    AS_MACRO uint32_t & asuint32_t()
    {
    	return *reinterpret_cast<uint32_t*>(this);
    }
    AS_MACRO const uint32_t & asuint32_t()const
    {
    	return *reinterpret_cast<const uint32_t*>(this);
    }
    AS_MACRO static RegSCR_EL3 make(uint32_t val)
    {
        RegSCR_EL3 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    AS_MACRO static RegSCR_EL3 read()
    { 
        RegSCR_EL3 res;
        __asm__ __volatile__("mrs %0,SCR_EL3\n\t":"=r"(res));
        return res;
    }
    AS_MACRO RegSCR_EL3 & update()
    {
        __asm__ __volatile__("mrs %0,SCR_EL3\n\t":"=r"(*this));
        return *this;
    }
    AS_MACRO void write()const
    {
        __asm__ __volatile__("msr SCR_EL3,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegRMR_EL1 
{
public:
    using ScaleType=uint32_t;
            uint32_t  AA64:1;
            uint32_t  RR:1;
            uint32_t  RES0_0:30;
    AS_MACRO uint32_t  get()const 
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    AS_MACRO uint32_t  get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }
    
    AS_MACRO RegRMR_EL1& set(uint32_t v)
    { 
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    AS_MACRO volatile RegRMR_EL1 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    AS_MACRO RegRMR_EL1 & setMandatoryFields()
    {
        AA64 = 0;
        RR = 0;
        RES0_0 = 0;
        return *this;
        }
    AS_MACRO RegRMR_EL1 copy()const volatile
    {
    	RegRMR_EL1 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO RegRMR_EL1 copy()const
    {
    	RegRMR_EL1 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO void dump()const volatile
    {
        kout << "RegRMR_EL1: ";
            kout
                << "AA64 = " << AA64 << ", "
                << "RR = " << RR << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "\n";
    }
    AS_MACRO void dump()const
    {
    	reinterpret_cast<volatile const RegRMR_EL1*>(this)->dump();
    }
    AS_MACRO uint32_t & asuint32_t()
    {
    	return *reinterpret_cast<uint32_t*>(this);
    }
    AS_MACRO const uint32_t & asuint32_t()const
    {
    	return *reinterpret_cast<const uint32_t*>(this);
    }
    AS_MACRO static RegRMR_EL1 make(uint32_t val)
    {
        RegRMR_EL1 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    AS_MACRO static RegRMR_EL1 read()
    { 
        RegRMR_EL1 res;
        __asm__ __volatile__("mrs %0,RMR_EL1\n\t":"=r"(res));
        return res;
    }
    AS_MACRO RegRMR_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,RMR_EL1\n\t":"=r"(*this));
        return *this;
    }
    AS_MACRO void write()const
    {
        __asm__ __volatile__("msr RMR_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegRMR_EL2 
{
public:
    using ScaleType=uint32_t;
            uint32_t  AA64:1;
            uint32_t  RR:1;
            uint32_t  RES0_0:30;
    AS_MACRO uint32_t  get()const 
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    AS_MACRO uint32_t  get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }
    
    AS_MACRO RegRMR_EL2& set(uint32_t v)
    { 
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    AS_MACRO volatile RegRMR_EL2 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    AS_MACRO RegRMR_EL2 & setMandatoryFields()
    {
        AA64 = 0;
        RR = 0;
        RES0_0 = 0;
        return *this;
        }
    AS_MACRO RegRMR_EL2 copy()const volatile
    {
    	RegRMR_EL2 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO RegRMR_EL2 copy()const
    {
    	RegRMR_EL2 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO void dump()const volatile
    {
        kout << "RegRMR_EL2: ";
            kout
                << "AA64 = " << AA64 << ", "
                << "RR = " << RR << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "\n";
    }
    AS_MACRO void dump()const
    {
    	reinterpret_cast<volatile const RegRMR_EL2*>(this)->dump();
    }
    AS_MACRO uint32_t & asuint32_t()
    {
    	return *reinterpret_cast<uint32_t*>(this);
    }
    AS_MACRO const uint32_t & asuint32_t()const
    {
    	return *reinterpret_cast<const uint32_t*>(this);
    }
    AS_MACRO static RegRMR_EL2 make(uint32_t val)
    {
        RegRMR_EL2 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    AS_MACRO static RegRMR_EL2 read()
    { 
        RegRMR_EL2 res;
        __asm__ __volatile__("mrs %0,RMR_EL2\n\t":"=r"(res));
        return res;
    }
    AS_MACRO RegRMR_EL2 & update()
    {
        __asm__ __volatile__("mrs %0,RMR_EL2\n\t":"=r"(*this));
        return *this;
    }
    AS_MACRO void write()const
    {
        __asm__ __volatile__("msr RMR_EL2,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegRMR_EL3 
{
public:
    using ScaleType=uint32_t;
            uint32_t  AA64:1;
            uint32_t  RR:1;
            uint32_t  RES0_0:30;
    AS_MACRO uint32_t  get()const 
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    AS_MACRO uint32_t  get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }
    
    AS_MACRO RegRMR_EL3& set(uint32_t v)
    { 
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    AS_MACRO volatile RegRMR_EL3 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    AS_MACRO RegRMR_EL3 & setMandatoryFields()
    {
        AA64 = 0;
        RR = 0;
        RES0_0 = 0;
        return *this;
        }
    AS_MACRO RegRMR_EL3 copy()const volatile
    {
    	RegRMR_EL3 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO RegRMR_EL3 copy()const
    {
    	RegRMR_EL3 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO void dump()const volatile
    {
        kout << "RegRMR_EL3: ";
            kout
                << "AA64 = " << AA64 << ", "
                << "RR = " << RR << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "\n";
    }
    AS_MACRO void dump()const
    {
    	reinterpret_cast<volatile const RegRMR_EL3*>(this)->dump();
    }
    AS_MACRO uint32_t & asuint32_t()
    {
    	return *reinterpret_cast<uint32_t*>(this);
    }
    AS_MACRO const uint32_t & asuint32_t()const
    {
    	return *reinterpret_cast<const uint32_t*>(this);
    }
    AS_MACRO static RegRMR_EL3 make(uint32_t val)
    {
        RegRMR_EL3 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    AS_MACRO static RegRMR_EL3 read()
    { 
        RegRMR_EL3 res;
        __asm__ __volatile__("mrs %0,RMR_EL3\n\t":"=r"(res));
        return res;
    }
    AS_MACRO RegRMR_EL3 & update()
    {
        __asm__ __volatile__("mrs %0,RMR_EL3\n\t":"=r"(*this));
        return *this;
    }
    AS_MACRO void write()const
    {
        __asm__ __volatile__("msr RMR_EL3,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));

#endif //__INCLUDE_ARCH_COMMON_AARCH64_REGISTERS_SYSTEM_COMMON_REGISTERS_H__
