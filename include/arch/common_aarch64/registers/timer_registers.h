//=====Automatically generated by python 3.6.4
//== working directory: /cygdrive/d/Pool/eclipse-workspace_aarch64/newspace/raspiOS/subprojects/python3_gen_engine/src
//== ../../../subprojects/python3_gen_engine/src/GenEngine.py  ../../../subprojects/python3_gen_engine/src/reg_defs/timer_registers.py  ../../../include/arch/common_aarch64/registers/timer_registers.h
#ifndef __INCLUDE_ARCH_COMMON_AARCH64_REGISTERS_TIMER_REGISTERS_H__
#define __INCLUDE_ARCH_COMMON_AARCH64_REGISTERS_TIMER_REGISTERS_H__
#include <def.h>
#include <io/Output.h>
#include <io/IntegerFormatter.h>

class RegCNTFRQ_EL0 
{
public:
    using ScaleType=uint32_t;
            uint32_t  ClockFrq:32;
    AS_MACRO uint32_t  get()const 
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    AS_MACRO uint32_t  get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }
    
    AS_MACRO RegCNTFRQ_EL0& set(uint32_t v)
    { 
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    AS_MACRO volatile RegCNTFRQ_EL0 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    AS_MACRO RegCNTFRQ_EL0 & setMandatoryFields()
    {
        ClockFrq = 0;
        return *this;
        }
    AS_MACRO RegCNTFRQ_EL0 copy()const volatile
    {
    	RegCNTFRQ_EL0 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO RegCNTFRQ_EL0 copy()const
    {
    	RegCNTFRQ_EL0 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO void dump()const volatile
    {
        kout << "RegCNTFRQ_EL0: ";
            kout
                << "ClockFrq = " << ClockFrq << ", "
                << "\n";
    }
    AS_MACRO void dump()const
    {
    	reinterpret_cast<volatile const RegCNTFRQ_EL0*>(this)->dump();
    }
    AS_MACRO uint32_t & asuint32_t()
    {
    	return *reinterpret_cast<uint32_t*>(this);
    }
    AS_MACRO const uint32_t & asuint32_t()const
    {
    	return *reinterpret_cast<const uint32_t*>(this);
    }
    AS_MACRO static RegCNTFRQ_EL0 make(uint32_t val)
    {
        RegCNTFRQ_EL0 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    AS_MACRO static RegCNTFRQ_EL0 read()
    { 
        RegCNTFRQ_EL0 res;
        __asm__ __volatile__("mrs %0,CNTFRQ_EL0\n\t":"=r"(res));
        return res;
    }
    AS_MACRO RegCNTFRQ_EL0 & update()
    {
        __asm__ __volatile__("mrs %0,CNTFRQ_EL0\n\t":"=r"(*this));
        return *this;
    }
    AS_MACRO void write()const
    {
        __asm__ __volatile__("msr CNTFRQ_EL0,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegCNTHCTL_EL2 
{
public:
    using ScaleType=uint32_t;
            uint32_t  EL1PCTEN:1;
            uint32_t  EL1PCEN:1;
            uint32_t  EVNTEN:1;
            uint32_t  EVNTDIR:1;
            uint32_t  EVNTI:4;
            uint32_t  RES0_0:24;
    AS_MACRO uint32_t  get()const 
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    AS_MACRO uint32_t  get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }
    
    AS_MACRO RegCNTHCTL_EL2& set(uint32_t v)
    { 
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    AS_MACRO volatile RegCNTHCTL_EL2 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    AS_MACRO RegCNTHCTL_EL2 & setMandatoryFields()
    {
        EL1PCTEN = 0;
        EL1PCEN = 0;
        EVNTEN = 0;
        EVNTDIR = 0;
        EVNTI = 0;
        RES0_0 = 0;
        return *this;
        }
    AS_MACRO RegCNTHCTL_EL2 copy()const volatile
    {
    	RegCNTHCTL_EL2 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO RegCNTHCTL_EL2 copy()const
    {
    	RegCNTHCTL_EL2 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO void dump()const volatile
    {
        kout << "RegCNTHCTL_EL2: ";
            kout
                << "EL1PCTEN = " << EL1PCTEN << ", "
                << "EL1PCEN = " << EL1PCEN << ", "
                << "EVNTEN = " << EVNTEN << ", "
                << "EVNTDIR = " << EVNTDIR << ", "
                << "EVNTI = " << EVNTI << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "\n";
    }
    AS_MACRO void dump()const
    {
    	reinterpret_cast<volatile const RegCNTHCTL_EL2*>(this)->dump();
    }
    AS_MACRO uint32_t & asuint32_t()
    {
    	return *reinterpret_cast<uint32_t*>(this);
    }
    AS_MACRO const uint32_t & asuint32_t()const
    {
    	return *reinterpret_cast<const uint32_t*>(this);
    }
    AS_MACRO static RegCNTHCTL_EL2 make(uint32_t val)
    {
        RegCNTHCTL_EL2 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    AS_MACRO static RegCNTHCTL_EL2 read()
    { 
        RegCNTHCTL_EL2 res;
        __asm__ __volatile__("mrs %0,CNTHCTL_EL2\n\t":"=r"(res));
        return res;
    }
    AS_MACRO RegCNTHCTL_EL2 & update()
    {
        __asm__ __volatile__("mrs %0,CNTHCTL_EL2\n\t":"=r"(*this));
        return *this;
    }
    AS_MACRO void write()const
    {
        __asm__ __volatile__("msr CNTHCTL_EL2,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegCNTKCTL_EL1 
{
public:
    using ScaleType=uint32_t;
            uint32_t  EL10PCTEN:1;
            uint32_t  EL0VCTEN:1;
            uint32_t  EVNTEN:1;
            uint32_t  EVNTDIR:1;
            uint32_t  EVNTI:4;
            uint32_t  EL0VTEN:1;
            uint32_t  EL0PTEN:1;
            uint32_t  RES0_0:22;
    AS_MACRO uint32_t  get()const 
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    AS_MACRO uint32_t  get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }
    
    AS_MACRO RegCNTKCTL_EL1& set(uint32_t v)
    { 
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    AS_MACRO volatile RegCNTKCTL_EL1 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    AS_MACRO RegCNTKCTL_EL1 & setMandatoryFields()
    {
        EL10PCTEN = 0;
        EL0VCTEN = 0;
        EVNTEN = 0;
        EVNTDIR = 0;
        EVNTI = 0;
        EL0VTEN = 0;
        EL0PTEN = 0;
        RES0_0 = 0;
        return *this;
        }
    AS_MACRO RegCNTKCTL_EL1 copy()const volatile
    {
    	RegCNTKCTL_EL1 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO RegCNTKCTL_EL1 copy()const
    {
    	RegCNTKCTL_EL1 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO void dump()const volatile
    {
        kout << "RegCNTKCTL_EL1: ";
            kout
                << "EL10PCTEN = " << EL10PCTEN << ", "
                << "EL0VCTEN = " << EL0VCTEN << ", "
                << "EVNTEN = " << EVNTEN << ", "
                << "EVNTDIR = " << EVNTDIR << ", "
                << "EVNTI = " << EVNTI << ", "
                << "EL0VTEN = " << EL0VTEN << ", "
                << "EL0PTEN = " << EL0PTEN << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "\n";
    }
    AS_MACRO void dump()const
    {
    	reinterpret_cast<volatile const RegCNTKCTL_EL1*>(this)->dump();
    }
    AS_MACRO uint32_t & asuint32_t()
    {
    	return *reinterpret_cast<uint32_t*>(this);
    }
    AS_MACRO const uint32_t & asuint32_t()const
    {
    	return *reinterpret_cast<const uint32_t*>(this);
    }
    AS_MACRO static RegCNTKCTL_EL1 make(uint32_t val)
    {
        RegCNTKCTL_EL1 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    AS_MACRO static RegCNTKCTL_EL1 read()
    { 
        RegCNTKCTL_EL1 res;
        __asm__ __volatile__("mrs %0,CNTKCTL_EL1\n\t":"=r"(res));
        return res;
    }
    AS_MACRO RegCNTKCTL_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,CNTKCTL_EL1\n\t":"=r"(*this));
        return *this;
    }
    AS_MACRO void write()const
    {
        __asm__ __volatile__("msr CNTKCTL_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegCNTP_CTL_EL0 
{
public:
    using ScaleType=uint32_t;
            uint32_t  ENABLE:1;
            uint32_t  IMASK:1;
            uint32_t  ISTATUS:1;
            uint32_t  RES0_0:29;
    AS_MACRO uint32_t  get()const 
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    AS_MACRO uint32_t  get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }
    
    AS_MACRO RegCNTP_CTL_EL0& set(uint32_t v)
    { 
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    AS_MACRO volatile RegCNTP_CTL_EL0 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    AS_MACRO RegCNTP_CTL_EL0 & setMandatoryFields()
    {
        ENABLE = 0;
        IMASK = 0;
        ISTATUS = 0;
        RES0_0 = 0;
        return *this;
        }
    AS_MACRO RegCNTP_CTL_EL0 copy()const volatile
    {
    	RegCNTP_CTL_EL0 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO RegCNTP_CTL_EL0 copy()const
    {
    	RegCNTP_CTL_EL0 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO void dump()const volatile
    {
        kout << "RegCNTP_CTL_EL0: ";
            kout
                << "ENABLE = " << ENABLE << ", "
                << "IMASK = " << IMASK << ", "
                << "ISTATUS = " << ISTATUS << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "\n";
    }
    AS_MACRO void dump()const
    {
    	reinterpret_cast<volatile const RegCNTP_CTL_EL0*>(this)->dump();
    }
    AS_MACRO uint32_t & asuint32_t()
    {
    	return *reinterpret_cast<uint32_t*>(this);
    }
    AS_MACRO const uint32_t & asuint32_t()const
    {
    	return *reinterpret_cast<const uint32_t*>(this);
    }
    AS_MACRO static RegCNTP_CTL_EL0 make(uint32_t val)
    {
        RegCNTP_CTL_EL0 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    AS_MACRO static RegCNTP_CTL_EL0 read()
    { 
        RegCNTP_CTL_EL0 res;
        __asm__ __volatile__("mrs %0,CNTP_CTL_EL0\n\t":"=r"(res));
        return res;
    }
    AS_MACRO RegCNTP_CTL_EL0 & update()
    {
        __asm__ __volatile__("mrs %0,CNTP_CTL_EL0\n\t":"=r"(*this));
        return *this;
    }
    AS_MACRO void write()const
    {
        __asm__ __volatile__("msr CNTP_CTL_EL0,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegCNTP_CVAL_EL0 
{
public:
    using ScaleType=uint64_t;
            uint64_t  CompareValue:64;
    AS_MACRO uint64_t  get()const 
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    AS_MACRO uint64_t  get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }
    
    AS_MACRO RegCNTP_CVAL_EL0& set(uint64_t v)
    { 
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    AS_MACRO volatile RegCNTP_CVAL_EL0 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    AS_MACRO RegCNTP_CVAL_EL0 & setMandatoryFields()
    {
        CompareValue = 0;
        return *this;
        }
    AS_MACRO RegCNTP_CVAL_EL0 copy()const volatile
    {
    	RegCNTP_CVAL_EL0 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO RegCNTP_CVAL_EL0 copy()const
    {
    	RegCNTP_CVAL_EL0 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO void dump()const volatile
    {
        kout << "RegCNTP_CVAL_EL0: ";
            kout
                << "CompareValue = " << CompareValue << ", "
                << "\n";
    }
    AS_MACRO void dump()const
    {
    	reinterpret_cast<volatile const RegCNTP_CVAL_EL0*>(this)->dump();
    }
    AS_MACRO uint64_t & asuint64_t()
    {
    	return *reinterpret_cast<uint64_t*>(this);
    }
    AS_MACRO const uint64_t & asuint64_t()const
    {
    	return *reinterpret_cast<const uint64_t*>(this);
    }
    AS_MACRO static RegCNTP_CVAL_EL0 make(uint64_t val)
    {
        RegCNTP_CVAL_EL0 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    AS_MACRO static RegCNTP_CVAL_EL0 read()
    { 
        RegCNTP_CVAL_EL0 res;
        __asm__ __volatile__("mrs %0,CNTP_CVAL_EL0\n\t":"=r"(res));
        return res;
    }
    AS_MACRO RegCNTP_CVAL_EL0 & update()
    {
        __asm__ __volatile__("mrs %0,CNTP_CVAL_EL0\n\t":"=r"(*this));
        return *this;
    }
    AS_MACRO void write()const
    {
        __asm__ __volatile__("msr CNTP_CVAL_EL0,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegCNTP_TVAL_EL0 
{
public:
    using ScaleType=int32_t;
            int32_t  TimerValue:32;
    AS_MACRO int32_t  get()const 
    {
        return *reinterpret_cast<const int32_t*>(this);
    }
    AS_MACRO int32_t  get()const volatile
    {
        return *reinterpret_cast<const volatile int32_t*>(this);
    }
    
    AS_MACRO RegCNTP_TVAL_EL0& set(int32_t v)
    { 
        *reinterpret_cast<int32_t*>(this)=v;
        return *this;
    }
    AS_MACRO volatile RegCNTP_TVAL_EL0 & set(int32_t v)volatile
    {
        *reinterpret_cast<volatile int32_t*>(this)=v;
        return *this;
    }
    AS_MACRO RegCNTP_TVAL_EL0 & setMandatoryFields()
    {
        TimerValue = 0;
        return *this;
        }
    AS_MACRO RegCNTP_TVAL_EL0 copy()const volatile
    {
    	RegCNTP_TVAL_EL0 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO RegCNTP_TVAL_EL0 copy()const
    {
    	RegCNTP_TVAL_EL0 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO void dump()const volatile
    {
        kout << "RegCNTP_TVAL_EL0: ";
            kout
                << "TimerValue = " << TimerValue << ", "
                << "\n";
    }
    AS_MACRO void dump()const
    {
    	reinterpret_cast<volatile const RegCNTP_TVAL_EL0*>(this)->dump();
    }
    AS_MACRO int32_t & asint32_t()
    {
    	return *reinterpret_cast<int32_t*>(this);
    }
    AS_MACRO const int32_t & asint32_t()const
    {
    	return *reinterpret_cast<const int32_t*>(this);
    }
    AS_MACRO static RegCNTP_TVAL_EL0 make(int32_t val)
    {
        RegCNTP_TVAL_EL0 res;
        *reinterpret_cast<int32_t*>(&res)=val;
        return res;
    }
    AS_MACRO static RegCNTP_TVAL_EL0 read()
    { 
        RegCNTP_TVAL_EL0 res;
        __asm__ __volatile__("mrs %0,CNTP_TVAL_EL0\n\t":"=r"(res));
        return res;
    }
    AS_MACRO RegCNTP_TVAL_EL0 & update()
    {
        __asm__ __volatile__("mrs %0,CNTP_TVAL_EL0\n\t":"=r"(*this));
        return *this;
    }
    AS_MACRO void write()const
    {
        __asm__ __volatile__("msr CNTP_TVAL_EL0,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegCNTPCT_EL0 
{
public:
    using ScaleType=uint64_t;
            uint64_t  PhysicalCount:64;
    AS_MACRO uint64_t  get()const 
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    AS_MACRO uint64_t  get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }
    
    AS_MACRO RegCNTPCT_EL0 & setMandatoryFields()
    {
        PhysicalCount = 0;
        return *this;
        }
    AS_MACRO void dump()const volatile
    {
        kout << "RegCNTPCT_EL0: ";
            kout
                << "PhysicalCount = " << PhysicalCount << ", "
                << "\n";
    }
    AS_MACRO void dump()const
    {
    	reinterpret_cast<volatile const RegCNTPCT_EL0*>(this)->dump();
    }
    AS_MACRO uint64_t & asuint64_t()
    {
    	return *reinterpret_cast<uint64_t*>(this);
    }
    AS_MACRO const uint64_t & asuint64_t()const
    {
    	return *reinterpret_cast<const uint64_t*>(this);
    }
    AS_MACRO static RegCNTPCT_EL0 make(uint64_t val)
    {
        RegCNTPCT_EL0 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    AS_MACRO static RegCNTPCT_EL0 read()
    { 
        RegCNTPCT_EL0 res;
        __asm__ __volatile__("isb; mrs %0,CNTPCT_EL0\n\t":"=r"(res));
        return res;
    }
    AS_MACRO RegCNTPCT_EL0 & update()
    {
        __asm__ __volatile__("isb; mrs %0,CNTPCT_EL0\n\t":"=r"(*this));
        return *this;
    }
}__attribute__((packed));


class RegCNTVCT_EL0 
{
public:
    using ScaleType=uint64_t;
            uint64_t  VirtualCountValue:64;
    AS_MACRO uint64_t  get()const 
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    AS_MACRO uint64_t  get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }
    
    AS_MACRO RegCNTVCT_EL0 & setMandatoryFields()
    {
        VirtualCountValue = 0;
        return *this;
        }
    AS_MACRO void dump()const volatile
    {
        kout << "RegCNTVCT_EL0: ";
            kout
                << "VirtualCountValue = " << VirtualCountValue << ", "
                << "\n";
    }
    AS_MACRO void dump()const
    {
    	reinterpret_cast<volatile const RegCNTVCT_EL0*>(this)->dump();
    }
    AS_MACRO uint64_t & asuint64_t()
    {
    	return *reinterpret_cast<uint64_t*>(this);
    }
    AS_MACRO const uint64_t & asuint64_t()const
    {
    	return *reinterpret_cast<const uint64_t*>(this);
    }
    AS_MACRO static RegCNTVCT_EL0 make(uint64_t val)
    {
        RegCNTVCT_EL0 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    AS_MACRO static RegCNTVCT_EL0 read()
    { 
        RegCNTVCT_EL0 res;
        __asm__ __volatile__("isb; mrs %0,CNTVCT_EL0\n\t":"=r"(res));
        return res;
    }
    AS_MACRO RegCNTVCT_EL0 & update()
    {
        __asm__ __volatile__("isb; mrs %0,CNTVCT_EL0\n\t":"=r"(*this));
        return *this;
    }
}__attribute__((packed));


class RegCNTV_CTL_EL0 
{
public:
    using ScaleType=uint32_t;
            uint32_t  ENABLE:1;
            uint32_t  IMASK:1;
            uint32_t  ISTATUS:1;
            uint32_t  RES0_0:29;
    AS_MACRO uint32_t  get()const 
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    AS_MACRO uint32_t  get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }
    
    AS_MACRO RegCNTV_CTL_EL0& set(uint32_t v)
    { 
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    AS_MACRO volatile RegCNTV_CTL_EL0 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    AS_MACRO RegCNTV_CTL_EL0 & setMandatoryFields()
    {
        ENABLE = 0;
        IMASK = 0;
        ISTATUS = 0;
        RES0_0 = 0;
        return *this;
        }
    AS_MACRO RegCNTV_CTL_EL0 copy()const volatile
    {
    	RegCNTV_CTL_EL0 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO RegCNTV_CTL_EL0 copy()const
    {
    	RegCNTV_CTL_EL0 res;
    	res.set(this->get());
    	return res;
    }
    AS_MACRO void dump()const volatile
    {
        kout << "RegCNTV_CTL_EL0: ";
            kout
                << "ENABLE = " << ENABLE << ", "
                << "IMASK = " << IMASK << ", "
                << "ISTATUS = " << ISTATUS << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "\n";
    }
    AS_MACRO void dump()const
    {
    	reinterpret_cast<volatile const RegCNTV_CTL_EL0*>(this)->dump();
    }
    AS_MACRO uint32_t & asuint32_t()
    {
    	return *reinterpret_cast<uint32_t*>(this);
    }
    AS_MACRO const uint32_t & asuint32_t()const
    {
    	return *reinterpret_cast<const uint32_t*>(this);
    }
    AS_MACRO static RegCNTV_CTL_EL0 make(uint32_t val)
    {
        RegCNTV_CTL_EL0 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    AS_MACRO static RegCNTV_CTL_EL0 read()
    { 
        RegCNTV_CTL_EL0 res;
        __asm__ __volatile__("mrs %0,CNTV_CTL_EL0\n\t":"=r"(res));
        return res;
    }
    AS_MACRO RegCNTV_CTL_EL0 & update()
    {
        __asm__ __volatile__("mrs %0,CNTV_CTL_EL0\n\t":"=r"(*this));
        return *this;
    }
    AS_MACRO void write()const
    {
        __asm__ __volatile__("msr CNTV_CTL_EL0,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));

#endif //__INCLUDE_ARCH_COMMON_AARCH64_REGISTERS_TIMER_REGISTERS_H__
